This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
3DFractalTree.vcxproj.filters
addons.make
bin/data/.gitkeep
bin/data/settings.json
bin/data/settings.xml
bin/data/Verdana.ttf
config.make
Constants.h
Ground.h
icon.rc
ofApp.cpp
Particle.h
README.md
src/main.cpp
src/ofApp.cpp
src/ofApp.h
Tree.cpp
Tree.h
Weather.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="addons.make">
ofxGui
</file>

<file path="bin/data/.gitkeep">

</file>

<file path="bin/data/settings.xml">
<?xml version="1.0"?>
</file>

<file path="config.make">

</file>

<file path="icon.rc">
// Icon Resource Definition
#define MAIN_ICON                       102

#if defined(_DEBUG)
MAIN_ICON               ICON                    "icon_debug.ico"
#else
MAIN_ICON               ICON                    "icon.ico"
#endif
</file>

<file path="ofApp.cpp">

</file>

<file path="src/main.cpp">
#include "ofMain.h"
#include "ofApp.h"

//========================================================================
int main( ){

	//Use ofGLFWWindowSettings for more options like multi-monitor fullscreen
	ofGLWindowSettings settings;
	settings.setSize(1024, 768);
	settings.windowMode = OF_WINDOW; //can also be OF_FULLSCREEN

	auto window = ofCreateWindow(settings);

	ofRunApp(window, std::make_shared<ofApp>());
	ofRunMainLoop();

}
</file>

<file path=".gitignore">
/bin/*
!/bin/data/
# audioフォルダ内の音声ファイルを無視
/bin/data/audio/*.mp3
/bin/data/audio/*.wav
# jsonやxmlは除外(追跡する)
!/bin/data/*.json
!/bin/data/*.xml
/obj/
/.vs/
*.sln
*.vcxproj
*.user
</file>

<file path="Particle.h">
#pragma once
#include "ofMain.h"

class Particle {
public:
    glm::vec3 pos, vel;
    ofColor color;
    float life = 1.0f;
    float decay;

    void setup(glm::vec3 p, glm::vec3 v, ofColor c) {
        pos = p;
        vel = v;
        color = c;
        life = 1.0f;
        decay = ofRandom(0.01f, 0.03f); // 約1〜3秒で消滅
    }

    void update(float dt) {
        pos += vel * (dt * 60.0f);
        life -= decay * (dt * 60.0f);
    }

    void draw() {
        // 寿命に応じて透明度とサイズを下げる
        ofSetColor(color, life * 255);
        ofDrawSphere(pos, 2.0f * life);
    }
};
</file>

<file path="Weather.h">
#pragma once
#include "ofMain.h"

enum WeatherState { SUNNY, RAINY, MOONLIGHT };

class Weather {
    // 2Dの雨線を管理する構造体
    struct RainLine {
        float x, y, speed, length;
    };
    vector<RainLine> rainLines;

public:
    WeatherState state = SUNNY;

    void setup() {
        rainLines.clear();
        // 画面全体に雨の線を初期配置
        for (int i = 0; i < 200; i++) {
            rainLines.push_back({ ofRandomWidth(), ofRandomHeight(), ofRandom(12, 25), ofRandom(15, 40) });
        }
    }

    void update() {
        if (state == RAINY) {
            for (auto& r : rainLines) {
                r.y += r.speed;
                if (r.y > ofGetHeight()) {
                    r.y = -r.length;
                    r.x = ofRandomWidth();
                }
            }
        }
    }

    // カメラの外（2D）で描画するメソッド
    void draw2D() {
        if (state == RAINY) {
            ofPushStyle();
            ofSetLineWidth(1);
            ofSetColor(170, 200, 255, 130); // 青白く少し透明な色
            for (auto& r : rainLines) {
                ofDrawLine(r.x, r.y, r.x, r.y + r.length);
            }
            ofPopStyle();
        }
    }

    void toggle() { state = static_cast<WeatherState>((state + 1) % 3); }
    void randomize() { state = static_cast<WeatherState>((int)ofRandom(0, 3)); }
    string getName() {
        if (state == SUNNY) return "SUNNY";
        if (state == RAINY) return "RAINY";
        return "MOONLIGHT";
    }
    // ofApp から渡された config を使って背景色を決定
    ofColor getBgFromConfig(const ofJson& config) {
        string key = "";
        if (state == SUNNY) key = "sunny_bg";
        else if (state == RAINY) key = "rainy_bg";
        else key = "moonlight_bg";

        auto c = config["weather"][key];
        return ofColor(c[0], c[1], c[2]);
    }

    float getGrowthBuff() { return 1.5f; }
};
</file>

<file path="3DFractalTree.vcxproj.filters">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="src\ofApp.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="src\main.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxBaseGui.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxButton.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxColorPicker.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiGroup.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxInputField.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxLabel.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxPanel.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSlider.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSliderGroup.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxToggle.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="ofApp.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="Tree.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{d8376475-7454-4a24-b08a-aac121d3ad6f}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons">
      <UniqueIdentifier>{2015A56A--6D1-1-44-79-A-EA4-9AEC96E18790}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons\ofxGui">
      <UniqueIdentifier>{C47F3DDD--9CE-7-4E-E5-8-762-A52490822872}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons\ofxGui\src">
      <UniqueIdentifier>{B62C1517--746-D-48-72-9-B81-6F33044A72E6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\ofApp.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxBaseGui.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxButton.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxColorPicker.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGui.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiGroup.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiUtils.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxInputField.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxLabel.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxPanel.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSlider.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSliderGroup.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxToggle.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="Ground.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Particle.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Tree.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Weather.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Constants.h">
      <Filter>src</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="icon.rc" />
  </ItemGroup>
</Project>
</file>

<file path="README.md">
# **3Dフラクタル成長シミュレーター 仕様書 Ver.10.0**

## **1\. プロジェクト概要**

C++およびopenFrameworks v0.12.1を用いた、フラクタル構造の動的生成および成長シミュレーター。VBOによる描画最適化、外部JSONによる定数管理、および専用のGUIシステムを備える。

## **2\. 操作方法**

### **メイン操作 (GUI / マウス)**

* **下部アクションバー**: 育成コマンド（WATER, FERTILIZE, KOTODAMA）の実行。  
* **右側成長スロット**: スキルアップグレード（GROWTH, RESIST, CATALYST）の実行。
* **ビューモード（Vキー）**: マウスドラッグ・ホイール操作でカメラ移動

### **キーボードショートカット**

| Key | 機能 |
| :---- | :---- |
| 1, 2, 3 | 育成コマンド (Water, Fertilizer, Kotodama) |
| V | View Mode (カメラ自由操作) の切り替え |
| D | デバッグ情報の表示/非表示切り替え |
| R | システムの全初期化 (Reset) |
| **(Debug Mode)** | **DキーがONの時のみ有効** |
| T | 日数を5日分進め、進化判定を強制実行 |
| E | 成長タイプをサイクル切り替え (DEFAULT \-\> ELEGANT \-\> STURDY \-\> ELDRITCH) |
| F | 花の形状をサイクル切り替え (NONE \-\> CRYSTAL \-\> PETAL \-\> SPIRIT) |
| P | スキルポイント無限化 (99ポイント固定) のトグル |
| Space | 時間（日数）の進行停止トグル |
| \+ / \= | 経験値を50ポイント加算 (レベルアップ演出のテスト用) |

## **3\. 技術仕様・システム構成**

### **3.1 描画エンジン (Tree クラス)**

* **VBOインデックス描画**: 枝、葉、花を単一の ofVboMesh に集約。  
* **枝の形状**: 1本の枝を縦方向に4分割（5断面）し、ねじれ（Twist）とテーパリングを実装。
* **LOD制御**: 再帰深度に基づき、断面の頂点数を 3〜5 に動的調整。

### **3.2 UI・演出システム (ofApp クラス)**

* **色加算合成 (OF\_BLENDMODE\_ADD)**: オーラおよびパーティクル描画などのエフェクト効果に適用。
* **レスポンシブ配置**: getUIScale() により、解像度 1024x768 を基準とした自動スケーリングを適用。

### **3.3 データ管理構造**

* **Constants.h**: 全データ構造 (GameState, UISettings, AuraBeam 等) および列挙型を単一ファイルに集約。  
* **settings.json**: 木の物理パラメータ、カメラ設定、天候背景色、UI座標、ボタン色、オーラ演出定数を外部保持。
## **3\. 技術仕様・主要機能**

### **3.4 成長システム**

* **進化分岐**: Day 20 (樹形分岐), Day 40 (開花分岐)。  
* **スキルバフ**: Resilience による副作用軽減、Catalyst による開花しきい値の緩和。  
* **デバッグHUD**: 画面左側のゲームUIの上に、FPS、頂点数、経験値詳細等のスタッツを透過重ね表示。

* **コマンドと増分・トレードオフ**:
  * **Water**: `depthExp`+, `長さ`++, `太さ`-, `変異度`--
  * **Fertilizer**: `depthExp`+, `長さ`-, `太さ`++, `変異度`-
  * **Kotodama**: `depthExp`++, `長さ`+, `太さ`-, `変異度`++

* **描画・最適化**
  * **縦方向分割 (Subdivision)**: 1つの枝を縦方向に4分割（5つの断面）して生成。ねじれ (Twist) / テーパリングを表現。
  * **法線計算**: 頂点ごとに法線（Normal）を設定。`ofLight`による平行光源（SUNNY）および点光源（MOONLIGHT）の陰影計算に対応。
  * **カメラ制御**:
    * 木の推定全高に基づき、注視点（Target）と距離（Distance）を自動計算し補間移動。
    * `settings.json`より回転速度、追従感度の調整が可能。

### **3.3 UI・視覚演出**
* **パラメータバー**: 現在値と最大値（Memory）を一つのバーに重ねて表示。
* **レスポンシブUI**: 基準解像度（1024x768）に対するウィンドウサイズ比率に基づきHUDを自動スケール。
* **3D/2Dパーティクル**:3D/2Dパーティクル: 育成、天候、および進化発生時にそれぞれ独立した物理挙動を持つパーティクルを生成。

## **4\. 外部設定ファイル (settings.json) 仕様**
* **tree**: 最大深度、経験値ベース値/指数、描画スケール、分岐角、各種色彩（RGB/HSB）。
* **camera**: 回転速度、補間速度、最小距離、高さ係数。
* **weather**: 各天候の背景色。
* **game**: 最大日数、スキルポイント付与間隔、コマンドごとの基礎増分値。
</file>

<file path="bin/data/settings.json">
{
    "tree": {
        "max_depth": 6,
        "depth_exp_base": 8.0,
        "depth_exp_power": 1.6,
        "length_visual_scale": 1.5,
        "thickness_visual_scale": 0.8,
        "branch_length_ratio": 0.75,
        "branch_thick_ratio": 0.7,
        "base_angle": 25.0,
        "mutation_angle_max": 45.0,
        "joint_scale": 1.05,
        "colors": {
            "trunk_hue_start": 20,
            "trunk_hue_end": 160,
            "leaf": [
                60,
                150,
                60,
                200
            ],
            "flower": [
                255,
                180,
                200
            ],
            "elegant": [
                180,
                220,
                255
            ],
            "sturdy": [
                150,
                255,
                100
            ],
            "eldritch": [
                255,
                50,
                100
            ],
            "aura_growth": [
                180,
                220,
                255
            ],
            "aura_resist": [
                150,
                255,
                100
            ],
            "aura_catalyst": [
                255,
                150,
                200
            ]
        }
    },
    "camera": {
        "rotation_speed": 0.2,
        "lerp_speed": 0.05,
        "min_distance": 600.0,
        "height_factor": 3.5
    },
    "weather": {
        "sunny_bg": [
            210,
            230,
            250
        ],
        "rainy_bg": [
            100,
            110,
            125
        ],
        "moonlight_bg": [
            20,
            25,
            45
        ]
    },
    "game": {
        "max_days": 50,
        "skill_interval": 5,
        "water_increment": 15.0,
        "fertilize_increment": 8.0,
        "evo_day_branch": 20,
        "evo_day_bloom": 40,
        "skill_costs": {
            "growth": 1,
            "resist": 1,
            "catalyst": 1
        }
    },
    "ui": {
        "labels": {
            "water": "WATER",
            "fertilizer": "FERTILIZE",
            "kotodama": "KOTODAMA"
        },
        "button": {
            "width": 160,
            "height": 50,
            "margin": 20,
            "bottom_offset": 60
        },
        "colors": {
            "idle": [
                60,
                60,
                70,
                200
            ],
            "hover": [
                100,
                100,
                130,
                255
            ],
            "active": [
                180,
                180,
                220,
                255
            ],
            "locked": [
                40,
                40,
                40,
                150
            ],
            "text": [
                255,
                255,
                255,
                255
            ]
        },
        "cooldown_time": 1.0,
        "status_pos": {
            "top": 30,
            "right": 30
        },
        "aura": {
            "duration": 1.5,
            "beam_count": 12,
            "flicker_speed": 15.0
        }
    },
    "audio": {
        "master_volume": 0.5,
        "bgm_volume_ratio": 0.7,
        "se_volume_ratio": 0.8,
        "bgm": {
            "sunny": "audio/bgm_sunny.mp3",
            "rainy": "audio/bgm_rainy.mp3",
            "moonlight": "audio/bgm_moonlight.mp3",
            "fade_duration": 1.5
        },
        "se": {
            "water": "audio/water.mp3",
            "fertilize": "audio/fertilizer.mp3",
            "kotodama": "audio/kotodama.mp3",
            "level_up": "audio/levelup.mp3"
        },
        "synth": {
            "base_freq": 440.0,
            "volume": 0.15
        }
    },
    "presets": [
    {
        "name": "0. Default (原初の樹)",
        "weather": "SUNNY",
        "evo_type": 0, "flower_type": 0,
        "aura_color": [255, 255, 255],
        "tree": {
            "max_depth": 6,
            "target_len": 120.0, "target_thick": 10.0, "target_mutation": 0.0,
            "base_angle": 25.0, "branch_length_ratio": 0.75,
            "trunk_hue_start": 20, "twist_factor": 0.0
        }
    },
    {
        "name": "1. Standard (生命の樹)",
        "weather": "SUNNY",
        "evo_type": 0, "flower_type": 2, // DEFAULT + PETAL
        "aura_color": [180, 220, 255],
        "tree": {
            "max_depth": 6,
            "target_len": 150.0, "target_thick": 12.0, "target_mutation": 0.2,
            "base_angle": 25.0, "branch_length_ratio": 0.75,
            "trunk_hue_start": 20, "twist_factor": 15.0
        }
    },
    {
        "name": "2. Sacred (聖なる光)",
        "weather": "MOONLIGHT",
        "evo_type": 1, "flower_type": 1, // ELEGANT + CRYSTAL
        "aura_color": [255, 255, 200],
        "tree": {
            "max_depth": 7,
            "target_len": 240.0, "target_thick": 8.0, "target_mutation": 0.1,
            "base_angle": 15.0, "branch_length_ratio": 0.85,
            "trunk_hue_start": 40, "twist_factor": 5.0,
            "leaf_color": [255, 255, 240]
        }
    },
    {
        "name": "3. Ancient (古の巨木)",
        "weather": "RAINY",
        "evo_type": 2, "flower_type": 2, // STURDY + PETAL
        "aura_color": [150, 255, 100],
        "tree": {
            "max_depth": 5,
            "target_len": 140.0, "target_thick": 35.0, "target_mutation": 0.05,
            "base_angle": 38.0, "branch_thick_ratio": 0.88,
            "trunk_hue_start": 80, "twist_factor": 45.0
        }
    },
    {
        "name": "4. Chaos (混沌の変異)",
        "weather": "MOONLIGHT",
        "evo_type": 3, "flower_type": 3, // ELDRITCH + SPIRIT
        "aura_color": [255, 50, 100],
        "tree": {
            "max_depth": 6,
            "target_len": 200.0, "target_thick": 15.0, "target_mutation": 0.9,
            "base_angle": 55.0, "branch_length_ratio": 0.65,
            "trunk_hue_start": 200, "twist_factor": 180.0
        }
    },
    {
        "name": "5. Cherry (薄紅の桜)",
        "weather": "SUNNY",
        "evo_type": 0, "flower_type": 2, // DEFAULT + PETAL
        "aura_color": [255, 200, 230],
        "tree": {
            "max_depth": 7,
            "target_len": 130.0, "target_thick": 10.0, "target_mutation": 0.1,
            "base_angle": 28.0, "branch_length_ratio": 0.7,
            "trunk_hue_start": 0, "twist_factor": 10.0,
            "leaf_color": [255, 180, 200]
        }
    },
    {
        "name": "6. Crystalline (氷晶の構造)",
        "weather": "RAINY",
        "evo_type": 1, "flower_type": 1, // ELEGANT + CRYSTAL
        "aura_color": [100, 200, 255],
        "tree": {
            "max_depth": 6,
            "target_len": 180.0, "target_thick": 14.0, "target_mutation": 0.4,
            "base_angle": 20.0, "branch_length_ratio": 0.8,
            "trunk_hue_start": 180, "twist_factor": 45.0,
            "leaf_color": [200, 230, 255]
        }
    }
],
    "effects": {
        "aura_layers": 4,
        "sigil_rotation_speed": 45.0,
        "kotodama": {
            "particle_count": 15,
            "spiral_speed": 8.0,
            "min_radius_ratio": 0.4,
            "max_radius_ratio": 0.8
        },
        "aura": {
            "duration": 1.8,
            "beam_count": 15,
            "flicker_speed": 40.0
        }
    }
}
</file>

<file path="Constants.h">
#pragma once
#include "ofMain.h"

enum GrowthType { TYPE_DEFAULT, TYPE_ELEGANT, TYPE_STURDY, TYPE_ELDRITCH };
enum FlowerType { FLOWER_NONE, FLOWER_CRYSTAL, FLOWER_PETAL, FLOWER_SPIRIT };
enum CommandType { CMD_WATER, CMD_FERTILIZER, CMD_KOTODAMA };
enum BarState { BAR_IDLE, BAR_LEVEL_UP_FLASH, BAR_RESET_WAIT };
enum ParticleType { P_WATER, P_FERTILIZER, P_KOTODAMA, P_RAIN_SPLASH, P_BLOOM };

// --- データ構造定義 ---
struct AuraBeam {
    float x, z;
    float width;
    float speed;
    float offset;
    float height;
};

struct EvolutionFlags {
    bool hasEvolvedType = false;
    bool hasEvolvedFlower = false;
    GrowthType type = TYPE_DEFAULT;
};

struct UISettings {
    string labelWater, labelFertilizer, labelKotodama;
    float btnW, btnH, btnMargin, btnBottomOffset;
    ofColor colIdle, colHover, colActive, colLocked, colText;
    ofColor colElegant, colSturdy, colEldritch;
    float cooldownDuration;
    float statusTop, statusRight;
    float btnClickOffset = 4.0f;
    ofColor colShadow = ofColor(0, 0, 0, 150);
};

struct AudioTrack {
    float currentVol = 0.0f;
    float targetVol = 0.0f;
};

struct AudioState {
    float volume = 0.2f;      // マスター音量
    float bgmRatio = 0.7f;      // BGM比率
    float seRatio = 1.0f;       // SE比率
    float phase = 0.0f;
    float phaseStep = 0.0f;
    float targetFreq = 440.0f;
    float currentFreq = 440.0f;
    float amplitude = 0.0f;   // 現在の音量（トリガーで上昇し、自動減衰する）
    float noiseMix = 0.0f;    // 混沌度に応じたノイズ混入率
    map<string, AudioTrack> bgmTracks; // 各BGMの状態を保持
    float fadeSpeed = 1.0f;            // フェードの速さ
};

struct SigilRing {
    float radius;
    float rotation;
    float speed;
    int resolution; // 3 = 三角形, 6 = 六角形など
};

struct TreeSettings {
    int maxDepth;
    float expBase, expPower;
    float lenScale, thickScale;
    float branchLenRatio, branchThickRatio;
    float baseAngle, mutationAngleMax;
    float trunkHueStart, trunkHueEnd;
    float twistFactor = 0.0f;
    ofColor leafColor, flowerColor;
};

struct GameState {
    int dayCount = 1;
    int skillPoints = 3;
    bool bGameEnded = false;
    bool bViewMode = false;
    bool bShowDebug = false;
    bool bTimeFrozen = false;
    bool bInfiniteSkills = false;
    string finalTitle = "";
    int maxDays = 50;
    GrowthType currentType = TYPE_DEFAULT;
    FlowerType currentFlowerType = FLOWER_NONE;
    int resilienceLevel = 0;
    float actionCooldown = 0.0f;

    bool bCinematicMode = false;
    float flashAlpha = 0.0f;
    int currentPresetIndex = 0;

    UISettings ui;

    EvolutionFlags evo;
    BarState barState = BAR_IDLE;
    float barFlashTimer = 0.0f;
    float auraTimer = 0.0f;
    float levelUpBubbleTimer = 0.0f;
    int lastCommandIndex = -1;
    ofColor auraColor = ofColor(255, 255, 255);

    AudioState audio;
    vector<SigilRing> sigils;

    int auraLayers = 2;
    float sigilRotationSpeed = 45.0f;
};

struct Particle2D {
    glm::vec2 pos, vel;
    ofColor color;
    float size, life = 1.0f, decay;
    ParticleType type;
    float angle = 0.0f;
    float spiralRadius = 0.0f; // 螺旋の初期半径

    void update(float dt) {
        if (type == P_KOTODAMA) {
            // 吸い込まれる螺旋ロジック
            angle += 8.0f * dt;
            // 寿命(life)が 1.0 -> 0.0 になるにつれて半径を縮小
            float currentR = spiralRadius * life;
            pos.x = ofGetWidth() * 0.5f + cos(angle) * currentR;
            pos.y = ofGetHeight() * 0.5f + sin(angle) * currentR;
            // サイズ：最初は大きく、徐々に小さく (25 -> 2)
            size = ofMap(life, 1.0f, 0.0f, 25.0f, 2.0f, true);
        }
        else if (type == P_RAIN_SPLASH) {
            // 波紋：位置固定、寿命のみ減衰
        }
        else {
            pos += vel * (dt * 60.0f);
        }
        life -= decay * (dt * 60.0f);
    }

    void draw() {
        if (type == P_RAIN_SPLASH) {
            // 復活：雨の波紋（広がる楕円）
            ofPushStyle();
            ofNoFill();
            ofSetLineWidth(2);
            ofSetColor(color, life * 150);
            float rippleW = (1.0f - life) * size * 4.0f;
            float rippleH = (1.0f - life) * size * 2.0f;
            ofDrawEllipse(pos, rippleW, rippleH);
            ofPopStyle();
        }
        else {
            // 通常の加算合成用の光る玉
            ofSetColor(0, 0, 0, life * 100); // 視認性用影
            ofDrawCircle(pos, size * 1.2f);
            ofSetColor(color, life * 255);
            ofDrawCircle(pos, size);
        }
    }
};
</file>

<file path="Tree.h">
#pragma once
#include "ofMain.h"
#include "Constants.h"

class Tree {
public:
    void setup(const ofJson& config); 
    void update(int growthLevel, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType);
    void draw();
    void reset();

    void water(float buff, int resilienceLevel, float increment);      // 長さを伸ばし、カオス度を下げる
    void fertilize(float buff, int resilienceLevel, float increment);  // 太さを増し、カオス度を下げる
    void kotodama(float buff);   // カオス度を上げる
    void applyEvolution(GrowthType type);
    void incrementDay() { if (dayCount < 50) dayCount++; }
    void addDebugExp(float amt) { depthExp += amt; }
    void setNeedsUpdate() { bNeedsUpdate = true; }

    void loadPresetConfig(const ofJson& presetTreeConfig); // 追加：プリセットの差分適用

    // --- アクセサ・ユーティリティ ---
    float getLen() { return bLen; }
    float getThick() { return bThick; }
    float getMaxMutation() { return maxMutationReached; }
    float getCurMutation() { return bMutation; }
    float getDepthExp() { return depthExp; }
    int getDepthLevel() { return depthLevel; }
    int getCurrentDepth();
    float getTotalLenEarned() { return totalLenEarned; }
    float getTotalThickEarned() { return totalThickEarned; }
    float getTotalMutationEarned() { return totalMutationEarned; }
    int getDayCount() { return dayCount; }
    int getSeed() { return seed; }
    float getDepthProgress();
    ofVboMesh& getVboMesh() { return vboMesh; }

private:
    // 内部ロジック：座標変換とメッシュ構築
    glm::mat4 getNextBranchMatrix(glm::mat4 tipMat, int index, int total, float angleBase);
    void buildBranchMesh(float length, float thickness, int depth, glm::mat4 mat, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType);
    void addStemToMesh(float r1, float r2, float h, glm::mat4 mat, int chaosResist,int depth, GrowthType gType);
    void addFlowerToMesh(float thickness, glm::mat4 mat, FlowerType type);
    void addLeafToMesh(float thickness, glm::mat4 mat);
    void addJointToMesh(float radius, glm::mat4 mat, ofColor col, int depth);
    float getExpForDepth(int d);

    // --- 育成パラメータ (b:現在値, t:目標値) ---
    float bLen = 0, bThick = 0, bMutation = 0;
    float tLen = 10, tThick = 2, tMutation = 0;
    float depthExp = 0;
    int depthLevel = 0;
    float totalLenEarned = 0;
    float totalThickEarned = 0;
    float totalMutationEarned = 0;

    // --- 状態管理 ---
    ofVboMesh vboMesh; 
    int seed;
    int dayCount = 1;
    float maxMutationReached = 0;
    float lastMutation = 0;
    bool bNeedsUpdate = true;

    // --- JSON定数 ---
    TreeSettings s;
};
</file>

<file path="Tree.cpp">
#include "Tree.h"
void Tree::setup(const ofJson& config) {
    seed = ofRandom(99999);
    auto t = config["tree"];
    s.maxDepth = t.value("max_depth", 6);
    s.expBase = t.value("depth_exp_base", 30.0f);
    s.expPower = t.value("depth_exp_power", 1.6f);
    s.lenScale = t.value("length_visual_scale", 1.5f);
    s.thickScale = t.value("thickness_visual_scale", 0.8f);
    s.branchLenRatio = t.value("branch_length_ratio", 0.75f);
    s.branchThickRatio = t.value("branch_thick_ratio", 0.7f);
    s.baseAngle = t.value("base_angle", 25.0f);
    s.mutationAngleMax = t.value("mutation_angle_max", 45.0f);

    auto c = t["colors"];
    s.trunkHueStart = c.value("trunk_hue_start", 20.0f);
    s.trunkHueEnd = c.value("trunk_hue_end", 160.0f);
    s.leafColor = ofColor(c["leaf"][0], c["leaf"][1], c["leaf"][2], c["leaf"][3]);

	// test value
    //s.twistFactor = 90.0f;
}

void Tree::update(int growthLevel, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType) {
    // 補間ロジックは維持
    bLen = ofLerp(bLen, tLen, 0.1f);
    bThick = ofLerp(bThick, tThick, 0.1f);
    bMutation = ofLerp(bMutation, tMutation, 0.1f);

    maxMutationReached = max(maxMutationReached, bMutation);

    if (depthLevel < s.maxDepth && depthExp >= getExpForDepth(depthLevel + 1)) {
        depthLevel++;
        bNeedsUpdate = true;
    }

    if (bNeedsUpdate || abs(bLen - tLen) > 0.5f || abs(bThick - tThick) > 0.1f) {
        vboMesh.clear();
        ofSetRandomSeed(seed);
        // 構造体 s を経由して描画パラメータを渡す
        buildBranchMesh(bLen * s.lenScale, bThick * s.thickScale, depthLevel, glm::mat4(1.0), chaosResist, bloomLevel, gType, fType);
        bNeedsUpdate = false;
    }
}

void Tree::draw() {
    vboMesh.draw();
}

void Tree::water(float buff, int resilienceLevel, float increment) {
    // デメリット軽減係数 (1レベルにつき15%軽減)
    float penaltyFactor = 1.0f - (resilienceLevel * 0.15f);

    depthExp += 5.0f * buff;

    float lenGain = increment * 2.0f * buff;
    tLen += lenGain;
    totalLenEarned += lenGain; // 累積加算

    // デメリット（太さ減少）に軽減を適用
    tThick = max(2.0f, tThick - (3.0f * penaltyFactor));
    tMutation = max(0.0f, tMutation - 0.1f);
}

void Tree::fertilize(float buff, int resilienceLevel, float increment) {
    float penaltyFactor = 1.0f - (resilienceLevel * 0.15f);

    depthExp += 5.0f * buff;

    // デメリット（長さ減少）に軽減を適用
    tLen = max(10.0f, tLen - (5.0f * penaltyFactor));

    float thickGain = increment * 2.0f * buff;
    tThick += thickGain;
    totalThickEarned += thickGain; // 累積加算

    tMutation = max(0.0f, tMutation - 0.05f);
}

void Tree::kotodama(float buff) {
    depthExp += 5.0f * buff;
    tLen += 10.0f * buff;
    tThick = max(2.0f, tThick - 5.0f);

    float mutGain = 0.2f * buff;
    tMutation = ofClamp(tMutation + mutGain, 0.0f, 1.0f);
    totalMutationEarned += mutGain; // 累積加算
}

void Tree::applyEvolution(GrowthType type) {
    switch (type) {
    case TYPE_ELEGANT:
        s.branchLenRatio = 0.82f;   // より長く伸びる
        s.baseAngle = 18.0f;        // 鋭角でスマートな印象
        s.twistFactor = 15.0f;      // 控えめなねじれ
        break;
    case TYPE_STURDY:
        s.branchThickRatio = 0.85f; // 太さを維持
        s.baseAngle = 35.0f;        // どっしりと広がる
        s.twistFactor = 40.0f;      // 力強いねじれ
        break;
    case TYPE_ELDRITCH:
        s.mutationAngleMax = 65.0f; // 予測不能な広がり
        s.twistFactor = 150.0f;     // 激しい螺旋
        s.trunkHueEnd += 100.0f;    // 色彩変化を拡大
        break;
    }
    bNeedsUpdate = true; // メッシュを再構築
}

glm::mat4 Tree::getNextBranchMatrix(glm::mat4 tipMat, int index, int total, float angleBase) {
    glm::mat4 m = tipMat;
    // Y軸回転で円状に配置
    m = glm::rotate(m, glm::radians(index * (360.0f / total)), glm::vec3(0, 1, 0));
    // 外側へ倒す回転（カオス度による揺らぎ）
    float wobble = ofRandom(-10, 10) * bMutation;
    m = glm::rotate(m, glm::radians(angleBase + wobble), glm::vec3(0, 0, 1));
    return m;
}

void Tree::buildBranchMesh(float length, float thickness, int depth, glm::mat4 mat, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType) {
    if (depth < 0) return;

    // 現在の枝（幹）をメッシュに追加
    addStemToMesh(thickness, thickness * s.branchThickRatio, length, mat, chaosResist, depth, gType);

    // 枝の先端の行列を計算
    glm::mat4 tipMat = glm::translate(mat, glm::vec3(0, length, 0));

    // --- 装飾（葉・花）のロジック ---
    float bloomThreshold = 0.4f - (bloomLevel * 0.05f);
    bool isBloomed = (maxMutationReached > bloomThreshold);

    if (depth == 0 && (isBloomed || fType != FLOWER_NONE)) {
        addFlowerToMesh(thickness, tipMat, fType);
    }
    else if (depth <= 1) {
        addLeafToMesh(thickness, tipMat);
    }

    // --- 次の枝への再帰 ---
    int numBranches = (depth < 2) ? 2 : 3;
    float angleBase = 25.0f + (bMutation * 45.0f); // カオス度で分岐角が広がる

    for (int i = 0; i < numBranches; i++) {
        glm::mat4 childMat = getNextBranchMatrix(tipMat, i, numBranches, angleBase);
        buildBranchMesh(length * s.branchLenRatio, thickness * s.branchThickRatio, depth - 1, childMat, chaosResist, bloomLevel, gType, fType);
    }
}

void Tree::addStemToMesh(float r1, float r2, float h, glm::mat4 mat, int chaosResist, int depth, GrowthType gType) {
    int segments = (depth <= 4) ? 3 : 5; // LOD: 深い枝ほど角数を減らす
    int subdivisions = 4;                // 縦方向の分割数
    int numRings = subdivisions + 1;

    // --- 色の計算 ---
    float timeShift = ofGetElapsedTimef() * 20.0f;
    if (gType == TYPE_ELDRITCH) {
        timeShift = ofGetElapsedTimef() * 100.0f; // Eldritchは激しく色が動く
    }
    float hueBase = ofMap(bMutation, 0, 1, s.trunkHueStart, s.trunkHueEnd);
    float finalHue = fmod(hueBase + timeShift + (depth * 10), 255.0f);
    ofColor col = ofColor::fromHsb(finalHue, 160, 180 + (depth * 10));
    
    float collapseThreshold = 0.9f + (chaosResist * 0.02f);
    // 法線変換用の行列
    glm::mat3 normalMatrix = glm::inverseTranspose(glm::mat3(mat));

    // 現在のVBOの頂点開始インデックスを記録
    int startIndex = vboMesh.getNumVertices();

    // 1. 頂点と法線の生成
    for (int ring = 0; ring < numRings; ring++) {
        float ratio = (float)ring / subdivisions;
        float currentR = ofLerp(r1, r2, ratio); // テーパリング
        float currentY = h * ratio;

        // 進化タイプや設定に応じた「ねじれ」の適用
        float twistAngle = glm::radians(s.twistFactor * ratio);

        for (int i = 0; i < segments; i++) {
            float angle = (i * TWO_PI / segments) + twistAngle;
            glm::vec3 unitPos(cos(angle), 0, sin(angle));

            // 頂点座標（ローカル）
            glm::vec4 p(unitPos.x * currentR, currentY, unitPos.z * currentR, 1);

            // カオス度が高い場合の頂点ノイズ（最上段に近いほど強く揺らす）
            if (maxMutationReached > 0.90f && ring > 0) {
                float nStr = ofMap(maxMutationReached, 0.5, 1.0, 0, 120.0f, true) * ratio;
                p.x += ofSignedNoise(p.x * 0.1, p.y * 0.1, ofGetElapsedTimef()) * nStr;
                p.z += ofSignedNoise(p.z * 0.1, p.y * 0.1, ofGetElapsedTimef() + 10) * nStr;
            }

            // VBOへの登録
            vboMesh.addVertex(glm::vec3(mat * p));
            vboMesh.addNormal(normalMatrix * unitPos); // 簡易法線
            vboMesh.addColor(col);
        }
    }

    // 2. インデックスの生成（面を貼る）
    for (int ring = 0; ring < subdivisions; ring++) {
        for (int i = 0; i < segments; i++) {
            int nextI = (i + 1) % segments;

            // 現在の層の2点
            int v0 = startIndex + (ring * segments) + i;
            int v1 = startIndex + (ring * segments) + nextI;
            // 次の層の2点
            int v2 = startIndex + ((ring + 1) * segments) + i;
            int v3 = startIndex + ((ring + 1) * segments) + nextI;

            // 三角形1
            vboMesh.addIndex(v0);
            vboMesh.addIndex(v1);
            vboMesh.addIndex(v2);

            // 三角形2
            vboMesh.addIndex(v1);
            vboMesh.addIndex(v3);
            vboMesh.addIndex(v2);
        }
    }
}

float Tree::getExpForDepth(int d) {
    if (d <= 0) return 0;
    return s.expBase * pow((float)d, s.expPower);
}

float Tree::getDepthProgress() {
    // 現在のレベルと次のレベルに必要な経験値を取得
    float curThreshold = getExpForDepth(depthLevel);
    float nxtThreshold = getExpForDepth(depthLevel + 1);

    // 0除算を防ぐ
    if (nxtThreshold <= curThreshold) return 1.0f;

    // 現在のレベル内での進捗率を 0.0 ~ 1.0 で返す
    return ofClamp((depthExp - curThreshold) / (nxtThreshold - curThreshold), 0.0f, 1.0f);
}

void Tree::addLeafToMesh(float thickness, glm::mat4 mat) {
    int startIndex = vboMesh.getNumVertices();
    ofColor lCol = s.leafColor;
    float w = thickness * 3.0f;
    float h = thickness * 6.0f;

    // 4頂点 (ひし形)
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, 0, 1)));           // 0: 付け根
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(-w, h * 0.5f, 0, 1)));   // 1: 左
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(w, h * 0.5f, 0, 1)));    // 2: 右
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, h, 0, 1)));           // 3: 先端

    for (int i = 0; i < 4; i++) {
        vboMesh.addNormal(glm::normalize(glm::mat3(mat) * glm::vec3(0, 0, 1)));
        vboMesh.addColor(lCol);
    }

    // インデックスで2つの三角形を形成
    vboMesh.addIndex(startIndex + 0); vboMesh.addIndex(startIndex + 1); vboMesh.addIndex(startIndex + 3);
    vboMesh.addIndex(startIndex + 0); vboMesh.addIndex(startIndex + 2); vboMesh.addIndex(startIndex + 3);
}

void Tree::addFlowerToMesh(float thickness, glm::mat4 mat, FlowerType type) {
    if (type == FLOWER_NONE) return;

    int startIndex = vboMesh.getNumVertices();
    ofColor fCol = s.flowerColor;

    if (type == FLOWER_CRYSTAL) {
        // 【Type A: 結晶】 放射状に広がる鋭い三角形
        float r = thickness * 4.0f;
        int numPoints = 6;
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, 0, 1))); // 中心
        vboMesh.addColor(fCol); vboMesh.addNormal(glm::vec3(0, 1, 0));

        for (int i = 0; i < numPoints; i++) {
            float ang = i * TWO_PI / numPoints;
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(cos(ang) * r, thickness, sin(ang) * r, 1)));
            vboMesh.addColor(fCol); vboMesh.addNormal(glm::vec3(0, 1, 0));

            vboMesh.addIndex(startIndex);
            vboMesh.addIndex(startIndex + 1 + i);
            vboMesh.addIndex(startIndex + 1 + (i + 1) % numPoints);
        }
    }
    else if (type == FLOWER_PETAL) {
        // 【Type B: 花弁】 5枚の柔らかい面
        float r = thickness * 3.5f;
        for (int i = 0; i < 5; i++) {
            int pStart = vboMesh.getNumVertices();
            float ang = i * TWO_PI / 5;
            // 簡易的な花びら1枚(三角形)
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, 0, 1)));
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(cos(ang - 0.3) * r, r * 0.5, sin(ang - 0.3) * r, 1)));
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(cos(ang + 0.3) * r, r * 0.5, sin(ang + 0.3) * r, 1)));
            for (int k = 0; k < 3; k++) { vboMesh.addColor(fCol); vboMesh.addNormal(glm::vec3(0, 1, 0)); }
            vboMesh.addIndex(pStart); vboMesh.addIndex(pStart + 1); vboMesh.addIndex(pStart + 2);
        }
    }
    else if (type == FLOWER_SPIRIT) {
        // 【Type C: 霊魂】 ゆらゆら揺れる尖った火の玉
        float r = thickness * 2.5f;
        float time = ofGetElapsedTimef() * 3.0f;
        float offset = ofSignedNoise(time) * 15.0f;

        vboMesh.addVertex(glm::vec3(mat * glm::vec4(offset, r * 5.0f, 0, 1))); // 尖った先端
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(-r, 0, -r, 1)));
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(r, 0, -r, 1)));
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, r, 1)));

        for (int k = 0; k < 4; k++) { vboMesh.addColor(ofColor(150, 200, 255, 180)); vboMesh.addNormal(glm::vec3(0, 1, 0)); }
        // 四面体のインデックス
        int idxs[] = { 0,1,2, 0,2,3, 0,3,1 };
        for (int id : idxs) vboMesh.addIndex(startIndex + id);
    }
}

void Tree::addJointToMesh(float radius, glm::mat4 mat, ofColor col, int depth) {
    // LOD: 先端の細い枝ほどポリゴンを削る
    int rings = (depth <= 2) ? 4 : 6;
    int sectors = (depth <= 2) ? 4 : 6;
    int startIndex = vboMesh.getNumVertices();
    glm::mat3 normalMatrix = glm::inverseTranspose(glm::mat3(mat));

    for (int r = 0; r <= rings; r++) {
        float phi = PI * (float)r / rings;
        for (int s = 0; s <= sectors; s++) {
            float theta = TWO_PI * (float)s / sectors;

            glm::vec3 unitPos(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(unitPos * radius, 1.0)));
            vboMesh.addNormal(normalMatrix * unitPos);
            vboMesh.addColor(col);
        }
    }

    for (int r = 0; r < rings; r++) {
        for (int s = 0; s < sectors; s++) {
            int v0 = startIndex + r * (sectors + 1) + s;
            int v1 = v0 + 1;
            int v2 = startIndex + (r + 1) * (sectors + 1) + s;
            int v3 = v2 + 1;
            vboMesh.addIndex(v0); vboMesh.addIndex(v1); vboMesh.addIndex(v2);
            vboMesh.addIndex(v1); vboMesh.addIndex(v3); vboMesh.addIndex(v2);
        }
    }
}

void Tree::loadPresetConfig(const ofJson& pt) {
    // ショーケース用の深度設定
    s.maxDepth = pt.value("max_depth", 6);
    depthLevel = s.maxDepth;
    depthExp = getExpForDepth(depthLevel);

    // 形状のバリエーションをパラメータから復元
    if (pt.contains("base_angle")) s.baseAngle = pt["base_angle"];
    if (pt.contains("branch_length_ratio")) s.branchLenRatio = pt["branch_length_ratio"];
    if (pt.contains("branch_thick_ratio")) s.branchThickRatio = pt["branch_thick_ratio"];
    if (pt.contains("trunk_hue_start")) s.trunkHueStart = pt["trunk_hue_start"];
    if (pt.contains("twist_factor")) s.twistFactor = pt["twist_factor"];

    // 葉の色の上書き
    if (pt.contains("leaf_color")) {
        auto c = pt["leaf_color"];
        s.leafColor = ofColor(c[0], c[1], c[2]);
    }

    // --- デモ用：目標値と現在値を同期 ---
    // これにより、Lerpを介さずに一瞬で「育ち切った姿」が表示されます
    tLen = pt.value("target_len", 150.0f);
    tThick = pt.value("target_thick", 12.0f);
    tMutation = pt.value("target_mutation", 0.0f);

    bLen = tLen;
    bThick = tThick;
    bMutation = tMutation;

    bNeedsUpdate = true;
}

void Tree::reset() {
    // 育成状態の完全初期化
    dayCount = 1;
    maxMutationReached = 0;
    depthExp = 0;
    depthLevel = 0;

    // 目標値と現在値を一気に 0 ではなく初期形状へ
    bLen = 0; tLen = 10;
    bThick = 0; tThick = 2;
    bMutation = 0; tMutation = 0;

    totalLenEarned = 0;
    totalThickEarned = 0;
    totalMutationEarned = 0;

    seed = ofRandom(99999);
    vboMesh.clear();
    bNeedsUpdate = true;
}

int Tree::getCurrentDepth() {
    return depthLevel;
}
</file>

<file path="src/ofApp.h">
#pragma once
#include "ofMain.h"
#include "ofxGui.h"
#include "..\Tree.h"
#include "..\Weather.h"
#include "..\Ground.h"
#include "../Particle.h"

//struct Particle2D {
//	glm::vec2 pos, vel;
//	ofColor color;
//	float size, life = 1.0, decay;
//	ParticleType type;
//
//	void update() {
//		pos += vel;
//		if (type == P_FERTILIZER) pos.x += sin(ofGetElapsedTimef() * 5.0) * 2.0;
//		life -= decay;
//	}
//
//	void draw() {
//		ofSetColor(color, life * 255);
//		if (type == P_RAIN_SPLASH) {
//			ofSetLineWidth(2);
//			ofNoFill();
//			ofDrawEllipse(pos, size * (1.0 - life) * 2.0, size * (1.0 - life));
//			ofFill();
//		}
//		else {
//			ofDrawCircle(pos, size * (life + 0.2));
//		}
//	}
//};

class ofApp : public ofBaseApp{
	public:
		// --- 標準イベント ---
		void setup();
		void update();
		void draw();
		void keyPressed(int key);
		void mousePressed(int x, int y, int button);

		void audioOut(ofSoundBuffer& buffer);
		void loadPreset(int index);
		void updateAudioEngine(float dt);
		void triggerSynthSE(float freq);

		// --- 各種イベント ---
		void keyReleased(int key);
		void mouseMoved(int x, int y );
		void mouseDragged(int x, int y, int button);
		void mouseReleased(int x, int y, int button);
		void mouseEntered(int x, int y);
		void mouseExited(int x, int y);
		void windowResized(int w, int h);
		void dragEvent(ofDragInfo dragInfo);
		void gotMessage(ofMessage msg);

	private:
		// ... UI描画メソッド群 ...
		void drawHUD();
		void drawRightGrowthSlots(float scale);
		void drawLeftStatusPanel(float scale);
		void drawCenterMessage(float scale);
		void drawStatusPanel();
		void drawBottomActionBar();
		void drawAura();
		void triggerAura(ofColor col);

		// ... ユーティリティ ...
		float getUIScale();
		void executeCommand(CommandType type);
		void updateCamera();
		void setupLighting();
		void spawn2DEffect(ParticleType type);
		void updateWeatherBGM();

		// --- スキル処理 ---
		void upgradeGrowth();
		void upgradeResist();
		void upgradeCatalyst();
		void checkEvolution();

		// --- システム変数 ---
		ofJson config;
		ofTrueTypeFont mainFont;
		GameState state;
		int hoveredSkillIndex = -1;
		vector<AuraBeam> auraBeams; // Constants.hの定義を使用

		// ... オブジェクト ...
		Tree myTree;
		Weather weather;
		Ground ground;
		ofEasyCam cam;
		ofLight light;
		vector<Particle> particles;
		vector<Particle2D> particles2D;

		// --- GUI ---
		ofxPanel gui;
		ofParameter<int> growthLevel, chaosResistLevel, bloomCatalystLevel;
		ofxButton btnGrowth, btnResist, btnCatalyst;

		// 音響リソース
		ofSoundStream soundStream;
		map<string, ofSoundPlayer> bgmMap;
		map<string, ofSoundPlayer> seMap;
		string currentBgmKey = "";

		void drawControlPanel();
		void drawViewModeOverlay();
		void drawDebugOverlay();
		void drawDualParamBar(string label, float x, float y, float w, float currentRatio, float maxRatio, ofColor col);
		int hoveredButtonIndex = -1;

		void processCommand(int key);
		void spawnBloomParticles();

		// --- システム変数と設定 ---
		float camAutoRotation = 0;
		float visualDepthProgress = 0;
		int lastDepthLevel = 0;
		ofColor auraColor;
};
</file>

<file path="src/ofApp.cpp">
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetFrameRate(60);
    ofEnableDepthTest();
    ofEnableSmoothing();

    config = ofLoadJson("settings.json");
    if (config.empty()) {
        ofLogError("ofApp") << "settings.json not found! Using hardcoded defaults.";
        config["game"]["water_increment"] = 15.0;
        config["game"]["fertilize_increment"] = 8.0;
        config["camera"]["height_factor"] = 3.5;
    }
    mainFont.load("verdana.ttf", 10, true, true);

    // UI設定の読み込み
    auto ui = config["ui"];
    state.ui.labelWater = ui["labels"].value("water", "WATER");
    state.ui.labelFertilizer = ui["labels"].value("fertilizer", "FERTILIZE");
    state.ui.labelKotodama = ui["labels"].value("kotodama", "KOTODAMA");

    state.ui.colElegant.set(180, 220, 255); // 暫定。後ほどJSONから取得
    state.ui.colSturdy.set(150, 255, 100);
    state.ui.colEldritch.set(255, 50, 100);

    auto btn = ui["button"];
    state.ui.btnW = btn.value("width", 160.0f);
    state.ui.btnH = btn.value("height", 50.0f);
    state.ui.btnMargin = btn.value("margin", 20.0f);
    state.ui.btnBottomOffset = btn.value("bottom_offset", 60.0f);

    auto col = ui["colors"];
    state.ui.colIdle.set(col["idle"][0], col["idle"][1], col["idle"][2], col["idle"][3]);
    state.ui.colHover.set(col["hover"][0], col["hover"][1], col["hover"][2], col["hover"][3]);
    state.ui.colActive.set(col["active"][0], col["active"][1], col["active"][2], col["active"][3]);
    state.ui.colLocked.set(col["locked"][0], col["locked"][1], col["locked"][2], col["locked"][3]);
    state.ui.colText.set(col["text"][0], col["text"][1], col["text"][2], col["text"][3]);

    state.ui.cooldownDuration = ui.value("cooldown_time", 1.0f);
    state.ui.statusTop = ui["status_pos"].value("top", 30.0f);
    state.ui.statusRight = ui["status_pos"].value("right", 30.0f);

    // state構造体の初期化
    state.skillPoints = 3;
    state.dayCount = 0;
    visualDepthProgress = 0;
    state.maxDays = config["game"].value("max_days", 50);
    state.bGameEnded = false;
    state.bViewMode = false;
    state.bShowDebug = false;

    state.currentPresetIndex = -1;

    myTree.setup(config);
    lastDepthLevel = myTree.getDepthLevel();


    weather.setup();
    ground.setup();

    // --- GUI初期化 ---
    gui.setup("Skill & Debug", "settings.xml", 20, 150);
    gui.add(growthLevel.set("Growth Efficiency", 0, 0, 5));
    gui.add(chaosResistLevel.set("Chaos Resistance", 0, 0, 5));
    gui.add(bloomCatalystLevel.set("Bloom Catalyst", 0, 0, 5));

    gui.add(btnGrowth.setup("Upgrade Growth (1pt)"));
    gui.add(btnResist.setup("Upgrade Resistance (1pt)"));
    gui.add(btnCatalyst.setup("Upgrade Bloom (1pt)"));

    btnGrowth.addListener(this, &ofApp::upgradeGrowth);
    btnResist.addListener(this, &ofApp::upgradeResist);
    btnCatalyst.addListener(this, &ofApp::upgradeCatalyst);

    ofEnableLighting();
    light.setup();
    cam.setDistance(400);
    cam.setGlobalPosition(ofVec3f(0, 150, 150));
    cam.lookAt(ofVec3f(0, 0, 0));
    cam.setNearClip(0.1);
    cam.setFarClip(20000);
    cam.setTarget(ofVec3f(0, 0, 0));
    cam.disableMouseInput();

    // 音響設定のロード
    auto audioCfg = config["audio"];
    state.audio.volume = audioCfg.value("master_volume", 0.5f);
    state.audio.bgmRatio = audioCfg.value("bgm_volume_ratio", 0.7f);
    state.audio.seRatio = audioCfg.value("se_volume_ratio", 1.0f);
    state.audio.fadeSpeed = 1.0f / audioCfg["bgm"].value("fade_duration", 1.5f);

    // BGMの準備
    string keys[] = { "sunny", "rainy", "moonlight" };
    for (auto& k : keys) {
        string path = audioCfg["bgm"].value(k, "");
        if (bgmMap[k].load(path)) {
            bgmMap[k].setLoop(true);
            bgmMap[k].setVolume(0);
            bgmMap[k].play(); // 無音で流し続ける
            state.audio.bgmTracks[k] = { 0.0f, 0.0f };
        }
    }
    for (auto& pair : bgmMap) pair.second.setLoop(true);

    // SEの準備
    auto seCfg = audioCfg["se"];
    for (auto it = seCfg.begin(); it != seCfg.end(); ++it) {
        string key = it.key();
        string path = it.value();
        bool loaded = seMap[key].load(path);
        seMap[key].setLoop(false);
        seMap[key].setMultiPlay(true); // SEは重なって再生OK
        if (!loaded) ofLogError("Audio") << "Failed to load SE: " << path;
    }

    // SoundStream開始 (2ch出力, 0ch入力, 44100Hz)
    ofSoundStreamSettings settings;
    settings.setOutListener(this);
    settings.sampleRate = 44100;
    settings.numOutputChannels = 2;
    settings.numInputChannels = 0;
    soundStream.setup(settings);

    updateWeatherBGM();
}

void ofApp::updateWeatherBGM() {
    // 現在の天候状態を文字列キーに変換
    string weatherKey = "";
    if (weather.state == SUNNY) weatherKey = "sunny";
    else if (weather.state == RAINY) weatherKey = "rainy";
    else if (weather.state == MOONLIGHT) weatherKey = "moonlight";

    // 全BGMトラックの目標音量を更新
    // 現在の天候に対応するトラックのみ 1.0f、それ以外を 0.0f に設定
    for (auto& pair : state.audio.bgmTracks) {
        pair.second.targetVol = (pair.first == weatherKey) ? 1.0f : 0.0f;
    }
}

void ofApp::loadPreset(int index) {
    if (index < 0 || index >= config["presets"].size()) return;

    state.currentPresetIndex = index;
    auto p = config["presets"][index];

    // 1. 木の完全リセットと完成ロード
    myTree.setup(config); 
    myTree.reset();
    myTree.loadPresetConfig(p["tree"]); 

    // 2. 天候の反映
    string wStr = p.value("weather", "SUNNY");
    if (wStr == "SUNNY") weather.state = SUNNY;
    else if (wStr == "RAINY") weather.state = RAINY;
    else if (wStr == "MOONLIGHT") weather.state = MOONLIGHT;
    updateWeatherBGM();

    // 3. デモ状態の固定
	state.dayCount = state.maxDays - ofRandom(0, 5);
    state.bGameEnded = true; 
    visualDepthProgress = 1.0f;
    state.flashAlpha = 1.0f;

    // 4. 進化タイプ・色の反映
    state.currentType = (GrowthType)p.value("evo_type", 0);
    state.currentFlowerType = (FlowerType)p.value("flower_type", 0);
    auto col = p["aura_color"];
    state.auraColor = ofColor(col[0], col[1], col[2]);
}

//--------------------------------------------------------------
void ofApp::update() {
    float dt = ofGetLastFrameTime();
    if (state.actionCooldown > 0) {
        state.actionCooldown -= dt;
        if (state.actionCooldown < 0) state.actionCooldown = 0;
    }
    // 終了判定
    if (myTree.getDayCount() >= state.maxDays && !state.bGameEnded) {
        state.bGameEnded = true;
        // 称号決定
        if (myTree.getLen() > 200 && myTree.getMaxMutation() < 0.3) state.finalTitle = "Elegant Giant";
        else if (myTree.getMaxMutation() > 0.8) state.finalTitle = "Herald of Chaos";
        else state.finalTitle = "Great Spirit Tree";
    }

    if (state.bShowDebug && state.bInfiniteSkills) {
        state.skillPoints = 99;
    }

    myTree.update(growthLevel, chaosResistLevel, bloomCatalystLevel, state.currentType, state.currentFlowerType);
    weather.update();

    updateCamera();

    // シンセ音のエンベロープ（減衰）処理
    state.audio.amplitude *= 0.92f;
    state.audio.currentFreq = ofLerp(state.audio.currentFreq, state.audio.targetFreq, 0.1f);
    // BGMクロスフェード処理
    for (auto& pair : state.audio.bgmTracks) {
        string key = pair.first;
        AudioTrack& track = pair.second;
        track.currentVol = ofLerp(track.currentVol, track.targetVol, state.audio.fadeSpeed * dt * 5.0f);

        // マスター音量 * BGM比率 * フェード値を適用
        bgmMap[key].setVolume(track.currentVol * state.audio.volume * state.audio.bgmRatio);
    }

    updateAudioEngine(dt); // シンセ音の更新

    visualDepthProgress = ofLerp(visualDepthProgress, myTree.getDepthProgress(), 0.1f);

    // パーティクル更新
    for (auto& p : particles) p.update(dt);
    ofRemove(particles, [](Particle& p) { return p.life <= 0; });
    for (auto& p : particles2D) p.update(dt);
    ofRemove(particles2D, [](Particle2D& p) { return p.life <= 0; });
    if (weather.state == RAINY && ofGetFrameNum() % 3 == 0) {
        spawn2DEffect(P_RAIN_SPLASH);
    }

    // レベルアップの検知ロジック
    int currentLvl = myTree.getDepthLevel();
    if (currentLvl > lastDepthLevel) {
        state.barState = BAR_LEVEL_UP_FLASH; // バーの発光アニメーション開始
        state.barFlashTimer = 0;
        lastDepthLevel = currentLvl;
    }
    // --- バーのアニメーション管理 ---
    if (state.barState == BAR_LEVEL_UP_FLASH) {
        state.barFlashTimer += ofGetLastFrameTime();
        if (state.barFlashTimer > 0.4f) { // 0.4秒発光を維持
            state.barState = BAR_RESET_WAIT;
            state.barFlashTimer = 0;
            state.levelUpBubbleTimer = 1.5f; // 「LEVEL UP!」表示開始
        }
    }
    else if (state.barState == BAR_RESET_WAIT) {
        visualDepthProgress = ofLerp(visualDepthProgress, 0, 0.2f);
        if (visualDepthProgress < 0.01f) {
            visualDepthProgress = 0;
            state.barState = BAR_IDLE;
        }
    }
    else {
        visualDepthProgress = ofLerp(visualDepthProgress, myTree.getDepthProgress(), 0.1f);
    }

    // --- オーラと演出タイマーの更新 ---
    if (state.auraTimer > 0) state.auraTimer -= ofGetLastFrameTime();
    if (state.levelUpBubbleTimer > 0) state.levelUpBubbleTimer -= ofGetLastFrameTime();
}

void ofApp::updateCamera() {
    if (state.bViewMode) return;

    float hFactor = config["camera"].value("height_factor", 3.5f);
    float treeH = myTree.getLen() * hFactor;
    float lerpSpeed = config["camera"].value("lerp_speed", 0.05f);
    float targetDist, lookAtY;

    if (state.bGameEnded) {
        camAutoRotation += 0.4f;
        targetDist = myTree.getLen() * 5.0f;
        lookAtY = treeH * 0.4f;

        float rad = ofDegToRad(camAutoRotation);
        cam.setPosition(sin(rad) * targetDist, lookAtY + 50, cos(rad) * targetDist);
        cam.lookAt(glm::vec3(0, lookAtY, 0));
    }
    else {
        float minDist = config["camera"].value("min_distance", 600.0f);
        float targetDist = std::max(minDist, treeH * 1.5f);
        float lookAtY = treeH * 0.4f;

        camAutoRotation += config["camera"].value("rotation_speed", 0.2f);
        float rad = ofDegToRad(camAutoRotation);

        glm::vec3 targetPos(sin(rad) * targetDist, lookAtY + 100, cos(rad) * targetDist);
        glm::vec3 targetLookAt(0, lookAtY, 0);

        // glm::mix (GLMのlerp) を使用してエラー回避 (修正点)
        cam.setPosition(glm::mix(cam.getPosition(), targetPos, lerpSpeed));
        cam.setTarget(glm::mix(cam.getTarget().getGlobalPosition(), targetLookAt, lerpSpeed));
    }
}

// --------------------------------------------------------------
void ofApp::updateAudioEngine(float dt) {
    // シンセ音の振幅を減衰させる（エンベロープ処理）
    // これにより「ポーン」という打楽器的な減衰音が生まれる
    state.audio.amplitude *= 0.94f;
    if (state.audio.amplitude < 0.001f) state.audio.amplitude = 0;

    // 周波数をターゲットへ滑らかに近づける（ポルタメント効果）
    state.audio.currentFreq = ofLerp(state.audio.currentFreq, state.audio.targetFreq, 0.15f);

    // カオス度（Mutation）が高い場合はノイズ成分を増やす
    state.audio.noiseMix = ofLerp(state.audio.noiseMix, myTree.getCurMutation() * 0.5f, 0.1f);
}

// --------------------------------------------------------------
void ofApp::triggerSynthSE(float freq) {
    state.audio.targetFreq = freq;
    state.audio.amplitude = state.audio.volume; // 音量を最大にして発音開始
}

// --------------------------------------------------------------
void ofApp::audioOut(ofSoundBuffer& buffer) {
    float sampleRate = 44100.0;
    for (size_t i = 0; i < buffer.getNumFrames(); i++) {
        state.audio.phaseStep = (TWO_PI * state.audio.currentFreq) / sampleRate;
        state.audio.phase += state.audio.phaseStep;

        // 純粋なサイン波
        float sineSample = sin(state.audio.phase);

        // 混沌度に応じたノイズ成分（ホワイトノイズ）
        float noiseSample = ofRandom(-1.0, 1.0);

        // ミックス
        float finalSample = (sineSample * (1.0f - state.audio.noiseMix)) + (noiseSample * state.audio.noiseMix);
        finalSample *= state.audio.amplitude;

        buffer.getSample(i, 0) = finalSample;
        buffer.getSample(i, 1) = finalSample;
    }
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofBackground(weather.getBgFromConfig(config));

    ofEnableDepthTest();
    ofEnableLighting();
    setupLighting();

    cam.begin();
    ground.draw();
    drawAura();
    myTree.draw();
    for (auto& p : particles) p.draw();
    cam.end();

    light.disable();
    ofDisableLighting();
    ofDisableDepthTest();

    ofEnableBlendMode(OF_BLENDMODE_ADD);
    for (auto& p : particles2D) p.draw();
    ofDisableBlendMode();

    weather.draw2D();

    if (state.bViewMode) drawViewModeOverlay();
    else if (!state.bCinematicMode) {
        drawHUD();
    }

    if (state.bShowDebug) drawDebugOverlay();
}

void ofApp::spawnBloomParticles() {
    for (int i = 0; i < 30; i++) {
        Particle p;
        p.setup(glm::vec3(0, myTree.getLen() * 2, 0),
            glm::vec3(ofRandom(-2, 2), ofRandom(2, 5), ofRandom(-2, 2)),
            ofColor(255, 150, 200));
        particles.push_back(p);
    }
}

//--------------------------------------------------------------
void ofApp::setupLighting() {
    // 天候ごとのライティング・プリセット
    switch (weather.state) {
    case SUNNY:
        light.setDirectional();
        light.setDiffuseColor(ofColor(255, 250, 230));
        light.setOrientation(glm::vec3(-45, -45, 0));
        break;
    case MOONLIGHT:
        light.setPointLight();
        light.setDiffuseColor(ofColor(120, 150, 255));
        light.setPosition(0, 500, 200);
        break;
    case RAINY:
        light.setPointLight();
        light.setDiffuseColor(ofColor(50, 60, 80));
        light.setPosition(0, 800, 0);
        break;
    }
    light.enable();
}

//--------------------------------------------------------------
float ofApp::getUIScale() {
    float baseW = 1024.0f; // 開発時の基準幅
    float baseH = 768.0f;  // 開発時の基準高さ
    // 縦横の比率のうち、小さい方に合わせることで画面外へのはみ出しを防ぐ
    return glm::min(ofGetWidth() / baseW, ofGetHeight() / baseH);
}

void ofApp::drawHUD() {
    float scale = getUIScale();
    ofPushMatrix();
    ofScale(scale, scale);

    // スキルパネル（デバッグ表示がONの時のみ）
    if (state.bShowDebug) {
        drawControlPanel();
    }

    ofPopMatrix(); // 一旦戻す（個別に座標計算するため）

    drawLeftStatusPanel(scale);  // 天候、進化印、デバッグ
    drawRightGrowthSlots(scale); // スキルボタン
    drawCenterMessage(scale);    // メッセージ、吹き出し

    drawStatusPanel();     // 右上へ
    drawBottomActionBar(); // 下部中央へ
}

string getFlowerName(FlowerType type) {
    switch (type) {
    case FLOWER_CRYSTAL: return "CRYSTAL";
    case FLOWER_PETAL: return "PETAL";
    case FLOWER_SPIRIT: return "SPIRIT";
    default: return "NONE";
    }
}


void ofApp::drawLeftStatusPanel(float scale) {
    ofPushMatrix();
    ofScale(scale, scale);
    ofTranslate(20, 20);

    // 0. 日数表示
    ofSetColor(255);
    string dayStr = "DAY: " + ofToString(myTree.getDayCount()) + " / " + ofToString(state.maxDays);
    if (state.bTimeFrozen) dayStr += " (FROZEN)";
    mainFont.drawString(dayStr, 0, 20);

    // 1. 天候バフ情報 (Y座標を 50, 70 に離す)
    ofSetColor(200, 230, 255);
    mainFont.drawString("WEATHER: " + weather.getName(), 0, 50);
    ofSetColor(255, 255, 0);
    string buff = (weather.state == SUNNY) ? "Buff: Water+" : (weather.state == RAINY) ? "Buff: Fertilizer+" : "Buff: Kotodama+";
    mainFont.drawString(buff, 0, 70);

    // 2. 進化達成の印 (Y座標 110 から開始)
    float symbolY = 110;
    auto drawSym = [&](bool active, string sym, ofColor col, string label) {
        ofSetColor(active ? col : ofColor(80));
        mainFont.drawString(sym + " " + label, 0, symbolY);
        symbolY += 30;
        };
    drawSym(state.evo.hasEvolvedType && state.currentType == TYPE_ELEGANT, "◇", state.ui.colElegant, "ELEGANT");
    drawSym(state.evo.hasEvolvedType && state.currentType == TYPE_STURDY, "□", state.ui.colSturdy, "STURDY");
    drawSym(state.evo.hasEvolvedType && state.currentType == TYPE_ELDRITCH, "◎", state.ui.colEldritch, "ELDRITCH");

    drawSym(state.evo.hasEvolvedFlower, "✿", ofColor(255, 150, 200), "BLOOM: " + getFlowerName(state.currentFlowerType));

    // 3. デバッグ設定のステータス表示
    if (state.bShowDebug) {
        ofSetColor(255, 100, 100);
        float dy = symbolY + 20;
        mainFont.drawString(">> DEBUG ACTIVE <<", 0, dy);
        mainFont.drawString(state.bInfiniteSkills ? "[P] INF SKILLS: ON" : "[P] INF SKILLS: OFF", 0, dy + 25);
        mainFont.drawString("[+] ADD EXP (Test LevelUp)", 0, dy + 50);
    }
    ofPopMatrix();
}

void ofApp::drawRightGrowthSlots(float scale) {
    float panelW = 200;
    float btnH = 60;
    float spacing = 70;

    ofPushMatrix();
    ofTranslate(ofGetWidth() - (panelW * scale) - 20, ofGetHeight() / 2 - (spacing * 1.5f) * scale);
    ofScale(scale, scale);

    hoveredSkillIndex = -1; // リセット
    // マウス座標をUI空間に変換
    float mx = (ofGetMouseX() - (ofGetWidth() - (panelW * scale) - 20)) / scale;
    float my = (ofGetMouseY() - (ofGetHeight() / 2 - (spacing * 1.5f) * scale)) / scale;

    string names[] = { "GROWTH", "RESIST", "CATALYST" };
    int levels[] = { growthLevel, chaosResistLevel, bloomCatalystLevel };
    int cost = 1;

    for (int i = 0; i < 3; i++) {
        float by = i * spacing;
        bool isHovered = (mx >= 0 && mx <= panelW && my >= by && my <= by + btnH);
        bool canAfford = (state.skillPoints >= cost);

        if (isHovered) {
            hoveredSkillIndex = i; // ホバー中のインデックスを保持
        }

        // 色の決定
        ofColor bCol = canAfford ? ofColor(100, 150, 255, 180) : ofColor(60, 150);
        if (isHovered && canAfford) bCol = ofColor(150, 200, 255, 255); // ホバー時は明るく

        ofSetColor(bCol);
        ofDrawRectRounded(0, by, panelW, btnH, 5);

        ofSetColor(255);
        mainFont.drawString(names[i], 10, by + 25);
        mainFont.drawString("LV." + ofToString(levels[i]), 10, by + 48);
        mainFont.drawString("COST: " + ofToString(cost), panelW - 80, by + 48);
    }
    // ... スキルポイント表示 ...
    ofSetColor(255, 200, 0);
    mainFont.drawString("SKILL POINTS: " + ofToString(state.skillPoints), 0, -20);
    ofPopMatrix();
}

// 画面中央のメッセージ（レベルアップ吹き出し・進化通知）を描画
void ofApp::drawCenterMessage(float scale) {
    ofPushStyle();
    ofPushMatrix();
    // 基準解像度に合わせてスケーリング
    ofScale(scale, scale);

    // 1. レベルアップの吹き出し ("LEVEL UP!")
    if (state.levelUpBubbleTimer > 0) {
        float alpha = ofMap(state.levelUpBubbleTimer, 0, 1.5, 0, 255, true);
        string msg = "LEVEL UP!";
        float tw = mainFont.stringWidth(msg);

        // 木の高さに依存せず、画面内の見やすい位置(中央より上)に固定
        float tx = (ofGetWidth() / scale) * 0.5f - tw * 0.5f;
        float ty = (ofGetHeight() / scale) * 0.35f; // 画面上部から35%の位置

        ofSetColor(255, 255, 255, alpha * 0.9);
        ofDrawRectRounded(tx - 20, ty - 30, tw + 40, 45, 10);
        ofDrawTriangle(tx + tw * 0.5f - 10, ty + 15, tx + tw * 0.5f + 10, ty + 15, tx + tw * 0.5f, ty + 35);

        ofSetColor(0, 0, 0, alpha);
        mainFont.drawString(msg, tx, ty + 5);
    }

    // 2. 進化完了メッセージ ("EVOLUTION COMPLETE")
    // Day 20 または Day 40 の当日のみ、画面中央に大きく表示
    int currentDay = myTree.getDayCount();
    if (currentDay == 20 || currentDay == 40) {
        // クールタイム中（アクション実行直後）に強調表示
        float alpha = ofMap(state.actionCooldown, 0, state.ui.cooldownDuration, 100, 255, true);

        string evoMsg = "EVOLUTION COMPLETE";
        float tw = mainFont.stringWidth(evoMsg);
        float tx = (ofGetWidth() / scale) * 0.5f - tw * 0.5f;
        float ty = (ofGetHeight() / scale) * 0.5f;

        // 文字の背後に帯状の背景
        ofSetColor(0, 0, 0, alpha * 0.6);
        ofDrawRectangle(0, ty - 40, ofGetWidth() / scale, 60);

        // 進化タイプに応じた色で強調
        ofColor evoCol = ofColor(255, 255, 0); // デフォルト
        if (currentDay == 20) {
            if (state.currentType == TYPE_ELEGANT) evoCol = state.ui.colElegant;
            else if (state.currentType == TYPE_STURDY) evoCol = state.ui.colSturdy;
            else if (state.currentType == TYPE_ELDRITCH) evoCol = state.ui.colEldritch;
        }

        ofSetColor(evoCol, alpha);
        mainFont.drawString(evoMsg, tx, ty);
    }

    ofPopMatrix();
    ofPopStyle();
}

// ステータスパネル（プログレスバー）の描画
void ofApp::drawStatusPanel() {
    float scale = getUIScale();
    float pW = 320, pH = 180;

    ofPushMatrix();
    // JSONの設定値に基づいて右上に配置
    float tx = ofGetWidth() - (pW * scale) - (state.ui.statusRight * scale);
    float ty = state.ui.statusTop * scale;
    ofTranslate(tx, ty);
    ofScale(scale, scale);

    // 背景
    ofSetColor(0, 160);
    ofDrawRectRounded(0, 0, pW, pH, 10);

    // パラメータバー描画（既存ロジックを流用）
    drawDualParamBar("Depth Level " + ofToString(myTree.getDepthLevel()), 25, 45, 270, visualDepthProgress, 0, ofColor(120, 255, 100));
    drawDualParamBar("Total Length", 25, 95, 270, ofClamp(myTree.getLen() / 400.0f, 0, 1), 0, ofColor(100, 200, 255));
    drawDualParamBar("Chaos (Cur / Max)", 25, 145, 270, myTree.getCurMutation(), myTree.getMaxMutation(), ofColor(255, 80, 150));
    ofPopMatrix();
}

void ofApp::drawBottomActionBar() {
    float scale = getUIScale();
    float btnW = state.ui.btnW;
    float btnH = state.ui.btnH;
    float margin = state.ui.btnMargin;
    int numBtns = 3;
    float totalW = (btnW * numBtns) + (margin * (numBtns - 1));

    ofPushMatrix();
    ofTranslate(ofGetWidth() / 2 - (totalW * scale) / 2, ofGetHeight() - (state.ui.btnBottomOffset * scale) - (btnH * scale));
    ofScale(scale, scale);

    string labels[] = { state.ui.labelWater, state.ui.labelFertilizer, state.ui.labelKotodama };
    CommandType types[] = { CMD_WATER, CMD_FERTILIZER, CMD_KOTODAMA };

    hoveredButtonIndex = -1;
    float mx = ofGetMouseX() / scale - (ofGetWidth() / 2 / scale - totalW / 2);
    float my = ofGetMouseY() / scale - (ofGetHeight() / scale - state.ui.btnBottomOffset - btnH);

    for (int i = 0; i < 3; i++) {
        float bx = i * (btnW + margin);
        bool isHover = (mx >= bx && mx <= bx + btnW && my >= 0 && my <= btnH);
        bool isPressed = isHover && ofGetMousePressed(); // Phase 2: 押し込み判定

        if (isHover) hoveredButtonIndex = i;

        // ボタンの沈み込み演出 (Phase 2)
        float yOff = isPressed ? state.ui.btnClickOffset : 0;

        ofSetColor(isPressed ? state.ui.colActive : (isHover ? state.ui.colHover : state.ui.colIdle));
        if (state.actionCooldown > 0) ofSetColor(state.ui.colLocked);

        ofDrawRectRounded(bx, yOff, btnW, btnH, 5);

        ofSetColor(state.ui.colText);
        mainFont.drawString(labels[i], bx + 20, btnH / 2 + 7 + yOff);

        // クールタイムゲージ
        if (state.actionCooldown > 0 && i == state.lastCommandIndex) {
            ofSetColor(state.ui.colActive);
            ofDrawRectangle(bx, btnH + yOff - 4, btnW * (state.actionCooldown / state.ui.cooldownDuration), 4);
        }
    }
    ofPopMatrix();
}

void ofApp::drawDualParamBar(string label, float x, float y, float w, float currentRatio, float maxRatio, ofColor col) {
    ofPushStyle();
    // 動的ラベル背景（文字の長さにフィット）
    float tw = mainFont.stringWidth(label) + 12;
    ofSetColor(0, 220);
    ofDrawRectangle(x - 2, y - 22, tw, 18);
    ofSetColor(255);
    mainFont.drawString(label, x + 3, y - 8);
    // バー背景
    ofSetColor(40);
    ofDrawRectangle(x, y, w, 14);
    // 最大値（記憶）の薄い表示
    if (maxRatio > 0) {
        ofSetColor(col, 60);
        ofDrawRectangle(x, y, w * maxRatio, 14);
    }
    // 現在値
    ofSetColor(col, 255);
    ofDrawRectangle(x, y, w * currentRatio, 14);
    ofPopStyle();
}

// コントロールパネルの描画
void ofApp::drawControlPanel() {
    float scale = glm::min(ofGetWidth() / 1024.0f, ofGetHeight() / 768.0f);
    ofPushStyle();
    ofPushMatrix();

    float panelW = 240; // 少し幅を広げる
    float panelH = 380; // 情報量に合わせて高くする
    ofTranslate(20 * scale, 120 * scale);

    // 背景
    ofSetColor(0, 0, 0, 180);
    ofDrawRectRounded(0, 0, panelW, panelH, 8);

    // --- 詳細ステータス表示 ---
    ofSetColor(255);
    int ty = 25;
    mainFont.drawString("=== TREE STATUS ===", 15, ty); ty += 25;
    ofSetColor(200, 255, 200);
    mainFont.drawString("Growth Lvl:  " + ofToString(growthLevel), 15, ty); ty += 18;
    ofSetColor(200, 200, 255);
    mainFont.drawString("Resist Lvl:  " + ofToString(chaosResistLevel), 15, ty); ty += 18;
    ofSetColor(255, 200, 200);
    mainFont.drawString("Catalyst:    " + ofToString(bloomCatalystLevel), 15, ty); ty += 25;

    // 天候ボーナス表示
    ofSetColor(255, 255, 0);
    string buffInfo = "Weather Buff: ";
    if (weather.state == SUNNY) buffInfo += "Water+";
    else if (weather.state == RAINY) buffInfo += "Fertilizer+";
    else if (weather.state == MOONLIGHT) buffInfo += "Kotodama+";
    mainFont.drawString(buffInfo, 15, ty); ty += 25;

    // 残り日数
    int maxDays = config["game"].value("max_days", 50);
    int daysLeft = maxDays - myTree.getDayCount();
    ofSetColor(255);
    mainFont.drawString("Days to Limit: " + ofToString(daysLeft), 15, ty); ty += 30;

    // ofxGuiの位置調整
    gui.setPosition(30, ty);
    gui.draw();

    // コマンドガイド
    ofSetColor(200);
    string cmds = "[1] Water  [2] Fertilizer\n[3] Kotodama\n\n'V' ViewMode  'D' Debug\n'R' Reset";
    mainFont.drawString(cmds, 15, panelH - 90);

    ofPopMatrix();
    ofPopStyle();
}

void ofApp::drawDebugOverlay() {
    float scale = getUIScale();
    ofPushStyle();
    ofScale(scale, scale);
    string d = "=== DEBUG INFO ===\n";
    d += "FPS: " + ofToString(ofGetFrameRate(), 1) + "\n";
    d += "VBO Vertices: " + ofToString(myTree.getVboMesh().getNumVertices()) + "\n";
    d += "2D Particles: " + ofToString(particles2D.size()) + "\n";
    d += "3D Particles: " + ofToString(particles.size()) + "\n";
    d += "------------------\n";
    d += "Depth: " + ofToString(myTree.getDepthLevel()) + " / " + ofToString(config["tree"].value("max_depth", 8)) + "\n";
    d += "Exp: " + ofToString(myTree.getDepthExp(), 1) + "\n";
    d += "Length: " + ofToString(myTree.getLen(), 1) + " (Target: " + ofToString(myTree.getLen(), 1) + ")\n";
    d += "Thick: " + ofToString(myTree.getThick(), 1) + "\n";
    d += "Mutation: " + ofToString(myTree.getMaxMutation(), 3);
    float dw = 300;
    ofSetColor(0, 200);
    ofDrawRectangle(ofGetWidth() / scale - dw - 20, 20, dw, 190);
    ofSetColor(0, 255, 0);
    mainFont.drawString(d, ofGetWidth() / scale - dw - 10, 40);

    ofPopMatrix();
    ofPopStyle();
}

// View Modeのオーバーレイ
void ofApp::drawViewModeOverlay() {
    ofPushStyle();
    string msg = "VIEW MODE : Orbit(Mouse) / Return('V')";
    float w = msg.length() * 8 + 20;
    ofSetColor(0, 0, 0, 200);
    ofDrawRectangle(ofGetWidth() / 2 - w / 2, ofGetHeight() - 50, w, 30);
    ofSetColor(255);
    ofDrawBitmapString(msg, ofGetWidth() / 2 - w / 2 + 10, ofGetHeight() - 30);
    ofPopStyle();
}

// 演出生成の実装
void ofApp::spawn2DEffect(ParticleType type) {
    float sw = ofGetWidth();
    float sh = ofGetHeight();
    float screenScale = getUIScale();

    int count = (type == P_RAIN_SPLASH) ? 1 : 60;

    for (int i = 0; i < count; i++) {
        Particle2D p;
        p.type = type;

        switch (type) {
        case P_WATER: {
            p.pos = { (float)ofRandomWidth(), -20.0f };
            p.vel = { ofRandom(-2, 2) * screenScale, ofRandom(8, 15) * screenScale };
            p.color = ofColor(120, 200, 255);
            p.size = ofRandom(12, 22) * screenScale;
            p.decay = ofRandom(0.004, 0.008);
        }break;

        case P_FERTILIZER: {
            p.pos = { (float)ofRandom(sw), (float)ofRandom(sh * 0.85f, sh) };
            p.vel = { ofRandom(-4, 4), ofRandom(-8.0f, -4.0f) };
            p.color = ofColor(180, 255, 100);
            p.size = ofRandom(10, 20) * screenScale;
            p.decay = ofRandom(0.005, 0.015);
        }break;

        case P_KOTODAMA: {
            auto& k = config["effects"]["kotodama"];
            auto c = config["tree"]["colors"]["elegant"];
            p.color = ofColor(c[0], c[1], c[2]);
            p.decay = ofRandom(0.01f, 0.02f);
            p.angle = ofRandom(TWO_PI);
            p.size = ofRandom(10, 20) * screenScale;
            float screenDiag = glm::length(glm::vec2(sw, sh));
            p.spiralRadius = ofRandom(k.value("min_radius_ratio", 0.4f), k.value("max_radius_ratio", 0.8f)) * screenDiag;
            p.life = 1.0f;
        }break;

        case P_RAIN_SPLASH: {
            p.pos = { ofRandomWidth(), ofRandom(ofGetHeight() * 0.8, ofGetHeight()) };
            p.vel = { 0, 0 };
            p.color = ofColor(150, 180, 255, 100);
            p.size = ofRandom(8, 16);
            p.decay = 0.05;
        }break;

        case P_BLOOM: {
            p.pos = { (float)ofGetWidth() / 2.0f + ofRandom(-150, 150),
                      (float)ofGetHeight() / 2.0f + ofRandom(-150, 150) };
            p.vel = { ofRandom(-2, 2), ofRandom(-2, 2) };
            p.color = ofColor(255, 200, 230);
            p.size = ofRandom(2, 4);
            p.decay = 0.02f;
        } break;
        }
        particles2D.push_back(p);
    }
}

// ヘルパー関数を追加：オーラ演出をトリガーする
void ofApp::triggerAura(ofColor col) {
    state.auraColor = col;
    auraBeams.clear();

    auto& a = config["effects"]["aura"];
    float treeH = myTree.getLen() * config["camera"].value("height_factor", 3.5f);
    float effectScale = std::max(1.0f, treeH / 200.0f);

    int count = config["ui"]["aura"].value("beam_count", 15);
    for (int i = 0; i < count; i++) {
        AuraBeam b;
        b.x = ofRandom(-150, 150) * effectScale;
        b.z = ofRandom(-150, 150) * effectScale;
        b.width = ofRandom(10, 30) * effectScale;
        b.speed = ofRandom(2, 6); 
        b.height = ofRandom(treeH * 1.2f,treeH * 1.2f + 200);
        auraBeams.push_back(b);
    }
    state.auraTimer = config["ui"]["aura"].value("duration", 1.8f);
}

// 描画メソッドの修正（十字板構造）
void ofApp::drawAura() {
    if (state.auraTimer <= 0) return;

    ofPushStyle();
    ofEnableBlendMode(OF_BLENDMODE_ADD);

    float progress = state.auraTimer / config["ui"]["aura"].value("duration", 1.8f);
    float flicker = 0.8f + 0.2f * sin(ofGetElapsedTimef() * 40.0f);

    for (auto& b : auraBeams) {
        float yAnim = fmod(ofGetElapsedTimef() * b.speed * 150.0f, 2500.0f);
        ofPushMatrix();
        ofTranslate(b.x, -yAnim + 1000, b.z);

        // 十字構造（90度回転させて2枚描画）
        for (int i = 0; i < 2; i++) {
            ofPushMatrix();
            if (i == 1) ofRotateYDeg(90);

            // 芯（白）
            ofSetColor(255, 255, 255, 150 * progress * flicker);
            ofDrawRectangle(-b.width * 0.1f, 0, b.width * 0.2f, b.height);

            // 外光（スキル別カラー）
            ofSetColor(state.auraColor, 100 * progress * flicker);
            ofDrawRectangle(-b.width * 0.5f, 0, b.width, b.height);
            ofPopMatrix();
        }
        ofPopMatrix();
    }
    ofDisableBlendMode();
    ofPopStyle();
}

void ofApp::executeCommand(CommandType type) {
    // クールタイム中、またはゲーム終了後は実行不可
    if (state.actionCooldown > 0 || state.bGameEnded || state.bViewMode) return;

    state.lastCommandIndex = static_cast<int>(type);

    auto& g = config["game"];
    float pitchBase = 440.0f + (myTree.getLen() * 0.5f);
    float seVol = state.audio.volume * state.audio.seRatio;

    switch (type) {
    case CMD_WATER:
        myTree.water(1.0, state.resilienceLevel, g.value("water_increment", 15.0f));
        spawn2DEffect(P_WATER);
        seMap["water"].setVolume(seVol);
        seMap["water"].play();
        triggerSynthSE(pitchBase);
        break;
    case CMD_FERTILIZER:
        myTree.fertilize(1.0, state.resilienceLevel, g.value("fertilize_increment", 8.0f));
        spawn2DEffect(P_FERTILIZER);
        seMap["fertilize"].setVolume(seVol);
        seMap["fertilize"].play();
        triggerSynthSE(pitchBase * 0.75f);
        break;
    case CMD_KOTODAMA:
        myTree.kotodama(1.0);
        spawn2DEffect(P_KOTODAMA);
        seMap["kotodama"].setVolume(seVol);
        seMap["kotodama"].play();
        triggerSynthSE(pitchBase * 1.5f);
        break;
    }

    // 共通の後処理
    if (!state.bTimeFrozen) {
        myTree.incrementDay();
        checkEvolution();
        if (myTree.getDayCount() % config["game"].value("skill_interval", 5) == 0) {
            state.skillPoints++;
        }
    }

    weather.randomize();
    updateWeatherBGM();  // BGMの目標音量を更新 (追加)

    // クールタイムの開始
    state.actionCooldown = state.ui.cooldownDuration;
}


//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == 'd' || key == 'D') state.bShowDebug = !state.bShowDebug;
    if (key == 'v' || key == 'V') {
        state.bViewMode = !state.bViewMode;
        state.bViewMode ? cam.enableMouseInput() : cam.disableMouseInput();
    }
    if (key == 'r' || key == 'R') {
        state.currentPresetIndex = -1;
        myTree.setup(config);
        myTree.reset();

        // 全てのゲーム状態を Day 1 に戻す
        state.dayCount = 0;
        state.skillPoints = 3;
        state.bGameEnded = false;
        state.currentType = TYPE_DEFAULT;
        state.currentFlowerType = FLOWER_NONE;
        visualDepthProgress = 0;
        lastDepthLevel = 0;
        growthLevel = 0;
        chaosResistLevel = 0;
        bloomCatalystLevel = 0;

        weather.state = SUNNY;
        updateWeatherBGM();
        ofLogNotice("System") << "Returned to Normal Gameplay (Day 0)";
    }
	// 音量調整
    if (key == '[') state.audio.volume = ofClamp(state.audio.volume - 0.05f, 0, 1);
    if (key == ']') state.audio.volume = ofClamp(state.audio.volume + 0.05f, 0, 1);
    if (state.bShowDebug) {
        if (key == '4') loadPreset(0);
        else if (key >= '5' && key <= '9') loadPreset(key - '5' + 1);
        else if (key == '0') loadPreset(6);

        // シネマティックモード切替
        if (key == 'h' || key == 'H') state.bCinematicMode = !state.bCinematicMode;
        if (key == 'w' || key == 'W') updateWeatherBGM(); weather.randomize();
        // [T]キーで日数を一気に進める
        if (key == 't' || key == 'T') {
            for (int i = 0; i < 5; i++) {
                myTree.incrementDay();
                checkEvolution();
            }
        }
        /// [E] 成長タイプのサイクル
        if (key == 'e' || key == 'E') {
            state.currentType = static_cast<GrowthType>((state.currentType + 1) % 4);
            myTree.applyEvolution(state.currentType);
            state.evo.hasEvolvedType = true;
            state.evo.type = state.currentType;
        }
        // [F] 花の形状のサイクル修正
        if (key == 'f' || key == 'F') {
            state.currentFlowerType = static_cast<FlowerType>((state.currentFlowerType + 1) % 4);
            state.evo.hasEvolvedFlower = (state.currentFlowerType != FLOWER_NONE);
            myTree.setNeedsUpdate(); // メッシュ再構築を強制
        }
        // [P] スキル無限トグル
        if (key == 'p' || key == 'P') state.bInfiniteSkills = !state.bInfiniteSkills;
        // [Space] 時間停止トグル
        if (key == ' ') state.bTimeFrozen = !state.bTimeFrozen;
        // [+] 経験値加算（レベルアップ演出のテスト用）
        if (key == '+' || key == '=') myTree.addDebugExp(50.0f);
    }
    processCommand(key);
}

void ofApp::processCommand(int key) {
    if (state.bViewMode || myTree.getDayCount() >= state.maxDays) return;

    bool actionTaken = false;
    auto& g = config["game"];

    // 開花判定用しきい値
    float threshold = 0.4f - (bloomCatalystLevel * 0.05f);
    bool wasBloomed = (myTree.getMaxMutation() > threshold);

    if (key == '1') executeCommand(CMD_WATER);
    if (key == '2') executeCommand(CMD_FERTILIZER);
    if (key == '3') executeCommand(CMD_KOTODAMA);

    if (actionTaken) {
        myTree.incrementDay();
        checkEvolution();
        if (myTree.getDayCount() % config["game"].value("skill_interval", 5) == 0) {
            state.skillPoints++;
        }
        weather.randomize();
    }
}

//--------------------------------------------------------------

// --- スキル処理 ---
void ofApp::upgradeGrowth() { 
    int cost = config["game"]["skill_costs"].value("growth", 1);
    if (state.skillPoints >= cost && growthLevel < 5) {
        growthLevel++; state.skillPoints--; 
        auto c = config["tree"]["colors"]["aura_growth"];
        triggerAura(ofColor(c[0], c[1], c[2]));
    } 
}
void ofApp::upgradeResist() {
    int cost = config["game"]["skill_costs"].value("resist", 1);
    if (state.skillPoints >= cost && chaosResistLevel < 5) { 
        chaosResistLevel++; state.skillPoints--; 
        auto c = config["tree"]["colors"]["aura_resist"];
        triggerAura(ofColor(c[0], c[1], c[2]));
    } 
}
void ofApp::upgradeCatalyst() {
    int cost = config["game"]["skill_costs"].value("catalyst", 1);
    if (state.skillPoints >= cost && bloomCatalystLevel < 5) { 
        bloomCatalystLevel++; state.skillPoints--; 
        auto c = config["tree"]["colors"]["aura_catalyst"];
        triggerAura(ofColor(c[0], c[1], c[2]));
    } 
}

void ofApp::checkEvolution() {
    auto& g = config["game"];
    int day = myTree.getDayCount();
    int dayBranch = g.value("evo_day_branch", 20);
    int dayBloom = g.value("evo_day_bloom", 40);
    // 20日目かつ、まだデフォルト状態の場合のみ実行
    if (day == dayBranch && state.currentType == TYPE_DEFAULT) {
        float L = myTree.getTotalLenEarned();
        float T = myTree.getTotalThickEarned();
        float M = myTree.getTotalMutationEarned();

        if (L >= T && L >= M) state.currentType = TYPE_ELEGANT;
        else if (T >= L && T >= M) state.currentType = TYPE_STURDY;
        else state.currentType = TYPE_ELDRITCH;

        myTree.applyEvolution(state.currentType);
        state.evo.hasEvolvedType = true;
        state.evo.type = state.currentType;
        spawn2DEffect(P_BLOOM);
    }
    if (day == dayBloom && state.currentFlowerType == FLOWER_NONE) {
        // 現在の成長タイプに応じて花の形を決定
        if (state.currentType == TYPE_ELEGANT) state.currentFlowerType = FLOWER_CRYSTAL;
        else if (state.currentType == TYPE_STURDY) state.currentFlowerType = FLOWER_PETAL;
        else state.currentFlowerType = FLOWER_SPIRIT;

        state.evo.hasEvolvedFlower = true;
        spawn2DEffect(P_BLOOM);
    }
}

void ofApp::keyReleased(int key) {}
void ofApp::mouseMoved(int x, int y) {}
void ofApp::mouseDragged(int x, int y, int button) {}

void ofApp::mousePressed(int x, int y, int button) {
    if (hoveredButtonIndex != -1) {
        CommandType types[] = { CMD_WATER, CMD_FERTILIZER, CMD_KOTODAMA };
        executeCommand(types[hoveredButtonIndex]);
    }
    if (hoveredSkillIndex != -1) {
        if (hoveredSkillIndex == 0) upgradeGrowth();
        else if (hoveredSkillIndex == 1) upgradeResist();
        else if (hoveredSkillIndex == 2) upgradeCatalyst();
    }
}

void ofApp::mouseReleased(int x, int y, int button) {}
void ofApp::mouseEntered(int x, int y) {}
void ofApp::mouseExited(int x, int y) {}
void ofApp::windowResized(int w, int h) {}
void ofApp::gotMessage(ofMessage msg) {}
void ofApp::dragEvent(ofDragInfo dragInfo) {}
</file>

</files>
