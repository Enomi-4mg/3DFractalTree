This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
3DFractalTree.vcxproj.filters
addons.make
bin/data/.gitkeep
bin/data/settings.json
bin/data/settings.xml
config.make
Constants.h
Ground.h
icon.rc
ofApp.cpp
Particle.h
README.md
src/main.cpp
src/ofApp.cpp
src/ofApp.h
Tree.cpp
Tree.h
Weather.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="addons.make">
ofxGui
</file>

<file path="bin/data/.gitkeep">

</file>

<file path="bin/data/settings.xml">
<?xml version="1.0"?>
</file>

<file path="config.make">

</file>

<file path="icon.rc">
// Icon Resource Definition
#define MAIN_ICON                       102

#if defined(_DEBUG)
MAIN_ICON               ICON                    "icon_debug.ico"
#else
MAIN_ICON               ICON                    "icon.ico"
#endif
</file>

<file path="ofApp.cpp">

</file>

<file path="src/main.cpp">
#include "ofMain.h"
#include "ofApp.h"

//========================================================================
int main( ){

	//Use ofGLFWWindowSettings for more options like multi-monitor fullscreen
	ofGLWindowSettings settings;
	settings.setSize(1024, 768);
	settings.windowMode = OF_WINDOW; //can also be OF_FULLSCREEN

	auto window = ofCreateWindow(settings);

	ofRunApp(window, std::make_shared<ofApp>());
	ofRunMainLoop();

}
</file>

<file path=".gitignore">
/bin/*
!/bin/data/
/obj/
/.vs/
*.sln
*.vcxproj
*.user
Verdana.ttf
</file>

<file path="Particle.h">
#pragma once
#include "ofMain.h"

class Particle {
public:
    glm::vec3 pos, vel;
    ofColor color;
    float life = 1.0f;
    float decay;

    void setup(glm::vec3 p, glm::vec3 v, ofColor c) {
        pos = p;
        vel = v;
        color = c;
        life = 1.0f;
        decay = ofRandom(0.01f, 0.03f); // 約1〜3秒で消滅
    }

    void update() {
        pos += vel;
        life -= decay;
    }

    void draw() {
        // 寿命に応じて透明度とサイズを下げる
        ofSetColor(color, life * 255);
        ofDrawSphere(pos, 2.0f * life);
    }
};
</file>

<file path="README.md">
# **3Dフラクタル成長シミュレーター 開発計画書 Ver.8.5**

## **1\. プロジェクト概要**

C++およびopenFrameworksを用いた、フラクタル構造の動的生成および成長シミュレーター。外部設定ファイル（JSON）によるパラメータ管理、VBOを用いた描画最適化、累進的経験値システムを特徴とする。

## **操作方法**

| button | 操作 |
| ------ | --- |
|1, 2, 3 | 育成コマンド実行 |
| V | View Mode (カメラ自由操作) 切替 |
| D | 詳細デバッグ情報の表示切替 |
| R | シミュレーターの全初期化 |
| T (Debug) | 日数を5日分進め、進化判定を実行 |
| E (Debug) | 成長タイプを「TYPE_ELDRITCH」へ強制変更 |
| F (Debug) | 花の形状を「FLOWER_SPIRIT」へ強制変更 |
| W (Debug) | 天候（Weather）切替（デバッグ用） |

## **2\. システム構成 (Architecture)**

* **開発環境**: Visual Studio 2022 / openFrameworks v0.12.1

* **外部依存**: ofxGui (標準アドオン)、verdana.ttf (フォントファイル)

* **データ管理**: `settings.json`による定数の外部保持（読み込み失敗時のフォールバック機能付き）。

* **主要クラス**:
  * **ofApp**: メインループ、入力管理、カメラ制御（自動追従/手動切替）、照明制御を担当、パーティクル寿命管理。 
  * **Tree**: フラクタル再帰計算（VBO構築）s、メッシュ生成、成長ロジック（Exp/Lv制）、パラメータ補間（Lerp）を担当。
  * **Weather**: 天候状態（SUNNY, RAINY, MOONLIGHT）の管理、背景色・バフ計算、2Dエフェクトを担当。
  * **Ground**: 平原の描画。
  * **Particle / Particle2D**: インスタンス化されたパーティクルの移動・描画ロジック。

## **3\. 技術仕様・主要機能**

### **3.1 成長システム**

* **経験値・レベル（深さ）管理**:
  * 木の「長さ（bLen）」と「太さ（bThick）」を独立した経験値として管理。
  * 枝の再帰深度（Depth）は、太さ（bThick）が指定の累積しきい値を超えた際に増加する。
  * しきい値計算式: $base \times depth^{power}$ （指数関数的な累進性）。

* **進化システム（不可逆分岐）**
  * **Day 20（成長タイプ分岐）**: 累積された長さ、太さ、変異度のうち最大の値に応じて「ELEGANT」「STURDY」「ELDRITCH」のいずれかに固定。
  * **Day 40（花の形状分岐）**: 成長タイプに応じて「CRYSTAL（結晶）」「PETAL（花弁）」「SPIRIT（霊魂）」の形状へ変化。

* **シームレス・アニメーション**:
  * 各パラメータは`lerp`により毎フレーム目標値へ補間される。
  * パラメータが一定以上の変化量を持つ期間のみ、`ofVboMesh`のクリアおよび再構築を実行し、CPU負荷を抑制。

* **コマンドと増分・トレードオフ**:
  * **Water**: `depthExp`+, `長さ`++, `太さ`-, `変異度`--
  * **Fertilizer**: `depthExp`+, `長さ`-, `太さ`++, `変異度`-
  * **Kotodama**: `depthExp`++, `長さ`+, `太さ`-, `変異度`++

* **描画・最適化**
  * **VBO集約**: 枝（五角柱/三角柱）、葉（菱形）、花（形状分岐）の全データを単一の`ofVboMesh`で管理し、インデックス参照によりドローコールを最適化。
  * **LOD (Level of Detail)**: 再帰深度に応じて幹のセグメント数（3〜5）を調整。
  * **法線計算**: 頂点ごとに法線（Normal）を設定。`ofLight`による平行光源（SUNNY）および点光源（MOONLIGHT）の陰影計算に対応。
  * **縦方向分割 (Subdivision)**: 1つの枝を縦方向に4分割（5つの断面）して生成。ねじれ (Twist) / テーパリングを表現。
  * **カメラ制御**:
    * 木の推定全高に基づき、注視点（Target）と距離（Distance）を自動計算し補間移動。
    * `settings.json`より回転速度、追従感度の調整が可能。

### **3.3 UI・視覚演出**
* **パラメータバー**: 現在値と最大値（Memory）を一つのバーに重ねて表示。
* **レスポンシブUI**: 基準解像度（1024x768）に対するウィンドウサイズ比率に基づきHUDを自動スケール。
* **3D/2Dパーティクル**:3D/2Dパーティクル: 育成、天候、および進化発生時にそれぞれ独立した物理挙動を持つパーティクルを生成。

## **4\. 外部設定ファイル (settings.json) 仕様**
* **tree**: 最大深度、経験値ベース値/指数、描画スケール、分岐角、各種色彩（RGB/HSB）。
* **camera**: 回転速度、補間速度、最小距離、高さ係数。
* **weather**: 各天候の背景色。
* **game**: 最大日数、スキルポイント付与間隔、コマンドごとの基礎増分値。

## **5\. 次のステップ (Roadmap)**
* **コマンドのGUI化**: ーボード操作をofxButton等による画面上でのマウス操作へ完全移行。
* **CGの改善**: 枝・幹同士のつなぎ目を滑らかにする。
* **UI改善**: 直感的な操作などインタラクションの強化。
</file>

<file path="Weather.h">
#pragma once
#include "ofMain.h"

enum WeatherState { SUNNY, RAINY, MOONLIGHT };

class Weather {
    // 2Dの雨線を管理する構造体
    struct RainLine {
        float x, y, speed, length;
    };
    vector<RainLine> rainLines;

public:
    WeatherState state = SUNNY;

    void setup() {
        rainLines.clear();
        // 画面全体に雨の線を初期配置
        for (int i = 0; i < 200; i++) {
            rainLines.push_back({ ofRandomWidth(), ofRandomHeight(), ofRandom(12, 25), ofRandom(15, 40) });
        }
    }

    void update() {
        if (state == RAINY) {
            for (auto& r : rainLines) {
                r.y += r.speed;
                if (r.y > ofGetHeight()) {
                    r.y = -r.length;
                    r.x = ofRandomWidth();
                }
            }
        }
    }

    // カメラの外（2D）で描画するメソッド
    void draw2D() {
        if (state == RAINY) {
            ofPushStyle();
            ofSetLineWidth(1);
            ofSetColor(170, 200, 255, 130); // 青白く少し透明な色
            for (auto& r : rainLines) {
                ofDrawLine(r.x, r.y, r.x, r.y + r.length);
            }
            ofPopStyle();
        }
    }

    void toggle() { state = static_cast<WeatherState>((state + 1) % 3); }
    void randomize() { state = static_cast<WeatherState>((int)ofRandom(0, 3)); }
    string getName() {
        if (state == SUNNY) return "SUNNY";
        if (state == RAINY) return "RAINY";
        return "MOONLIGHT";
    }
    // ofApp から渡された config を使って背景色を決定
    ofColor getBgFromConfig(const ofJson& config) {
        string key = "";
        if (state == SUNNY) key = "sunny_bg";
        else if (state == RAINY) key = "rainy_bg";
        else key = "moonlight_bg";

        auto c = config["weather"][key];
        return ofColor(c[0], c[1], c[2]);
    }

    float getGrowthBuff() { return 1.5f; }
};
</file>

<file path="3DFractalTree.vcxproj.filters">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="src\ofApp.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="src\main.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxBaseGui.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxButton.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxColorPicker.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiGroup.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxInputField.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxLabel.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxPanel.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSlider.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSliderGroup.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxToggle.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="ofApp.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="Tree.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{d8376475-7454-4a24-b08a-aac121d3ad6f}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons">
      <UniqueIdentifier>{2015A56A--6D1-1-44-79-A-EA4-9AEC96E18790}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons\ofxGui">
      <UniqueIdentifier>{C47F3DDD--9CE-7-4E-E5-8-762-A52490822872}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons\ofxGui\src">
      <UniqueIdentifier>{B62C1517--746-D-48-72-9-B81-6F33044A72E6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\ofApp.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxBaseGui.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxButton.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxColorPicker.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGui.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiGroup.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiUtils.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxInputField.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxLabel.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxPanel.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSlider.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSliderGroup.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxToggle.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="Ground.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Particle.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Tree.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Weather.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Constants.h">
      <Filter>src</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="icon.rc" />
  </ItemGroup>
</Project>
</file>

<file path="bin/data/settings.json">
{
    "tree": {
        "max_depth": 6,
        "depth_exp_base": 8.0,
        "depth_exp_power": 1.6,
        "length_visual_scale": 1.5,
        "thickness_visual_scale": 0.8,
        "branch_length_ratio": 0.75,
        "branch_thick_ratio": 0.7,
        "base_angle": 25.0,
        "mutation_angle_max": 45.0,
        "joint_scale": 1.05,
        "colors": {
            "trunk_hue_start": 20,
            "trunk_hue_end": 160,
            "leaf": [60, 150, 60, 200],
            "flower": [255, 180, 200],
            "elegant": [180, 220, 255], 
            "sturdy": [150, 255, 100],
            "eldritch": [255, 50, 100]
        }
    },
    "camera": {
        "rotation_speed": 0.2,
        "lerp_speed": 0.05,
        "min_distance": 600.0,
        "height_factor": 3.5
    },
    "weather": {
        "sunny_bg": [210, 230, 250],
        "rainy_bg": [100, 110, 125],
        "moonlight_bg": [20, 25, 45]
    },
    "game": {
        "max_days": 50,
        "skill_interval": 5,
        "water_increment": 15.0,
        "fertilize_increment": 8.0
    },
    "ui": {
        "labels": {
            "water": "WATER",
            "fertilizer": "FERTILIZE",
            "kotodama": "KOTODAMA"
        },
        "button": {
            "width": 160,
            "height": 50,
            "margin": 20,
            "bottom_offset": 60
        },
        "colors": {
            "idle": [60, 60, 70, 200],
            "hover": [100, 100, 130, 255],
            "active": [180, 180, 220, 255],
            "locked": [40, 40, 40, 150],
            "text": [255, 255, 255, 255]
        },
        "cooldown_time": 1.0,
        "status_pos": {
            "top": 30,
            "right": 30
        },
        "aura": {
            "duration": 1.5,
            "beam_count": 12,
            "flicker_speed": 15.0
        },
        "skill_costs": {
            "growth": 1,
            "resist": 1,
            "catalyst": 1
        }
    }
}
</file>

<file path="Constants.h">
#pragma once
#include "ofMain.h"

enum GrowthType { TYPE_DEFAULT, TYPE_ELEGANT, TYPE_STURDY, TYPE_ELDRITCH };
enum FlowerType { FLOWER_NONE, FLOWER_CRYSTAL, FLOWER_PETAL, FLOWER_SPIRIT };
enum CommandType { CMD_WATER, CMD_FERTILIZER, CMD_KOTODAMA };
enum BarState { BAR_IDLE, BAR_LEVEL_UP_FLASH, BAR_RESET_WAIT };
enum ParticleType { P_WATER, P_FERTILIZER, P_KOTODAMA, P_RAIN_SPLASH, P_BLOOM };

// --- データ構造定義 ---
struct AuraBeam {
    float x, z;
    float width;
    float speed;
    float offset;
    float height;
};

struct EvolutionFlags {
    bool hasEvolvedType = false;
    bool hasEvolvedFlower = false;
    GrowthType type = TYPE_DEFAULT;
};

struct UISettings {
    string labelWater, labelFertilizer, labelKotodama;
    float btnW, btnH, btnMargin, btnBottomOffset;
    ofColor colIdle, colHover, colActive, colLocked, colText;
    ofColor colElegant, colSturdy, colEldritch;
    float cooldownDuration;
    float statusTop, statusRight;
};

struct TreeSettings {
    int maxDepth;
    float expBase, expPower;
    float lenScale, thickScale;
    float branchLenRatio, branchThickRatio;
    float baseAngle, mutationAngleMax;
    float trunkHueStart, trunkHueEnd;
    float twistFactor = 0.0f;
    ofColor leafColor, flowerColor;
};

struct GameState {
    int dayCount = 1;
    int skillPoints = 3;
    bool bGameEnded = false;
    bool bViewMode = false;
    bool bShowDebug = false;
    bool bTimeFrozen = false;
    bool bInfiniteSkills = false;
    string finalTitle = "";
    int maxDays = 50;
    GrowthType currentType = TYPE_DEFAULT;
    FlowerType currentFlowerType = FLOWER_NONE;
    int resilienceLevel = 0;
    float actionCooldown = 0.0f;
    UISettings ui;

    EvolutionFlags evo;
    BarState barState = BAR_IDLE;
    float barFlashTimer = 0.0f;
    float auraTimer = 0.0f;
    float levelUpBubbleTimer = 0.0f;
};
</file>

<file path="src/ofApp.h">
#pragma once
#include "ofMain.h"
#include "ofxGui.h"
#include "..\Tree.h"
#include "..\Weather.h"
#include "..\Ground.h"
#include "../Particle.h"

struct Particle2D {
	glm::vec2 pos, vel;
	ofColor color;
	float size, life = 1.0, decay;
	ParticleType type;

	void update() {
		pos += vel;
		if (type == P_FERTILIZER) pos.x += sin(ofGetElapsedTimef() * 5.0) * 2.0;
		life -= decay;
	}

	void draw() {
		ofSetColor(color, life * 255);
		if (type == P_RAIN_SPLASH) {
			ofSetLineWidth(2);
			ofNoFill();
			ofDrawEllipse(pos, size * (1.0 - life) * 2.0, size * (1.0 - life));
			ofFill();
		}
		else {
			ofDrawCircle(pos, size * (life + 0.2));
		}
	}
};

class ofApp : public ofBaseApp{
	public:
		// --- 標準イベント ---
		void setup();
		void update();
		void draw();
		void keyPressed(int key);
		void mousePressed(int x, int y, int button);

		// --- 各種イベント ---
		void keyReleased(int key);
		void mouseMoved(int x, int y );
		void mouseDragged(int x, int y, int button);
		void mouseReleased(int x, int y, int button);
		void mouseEntered(int x, int y);
		void mouseExited(int x, int y);
		void windowResized(int w, int h);
		void dragEvent(ofDragInfo dragInfo);
		void gotMessage(ofMessage msg);

	private:
		// ... UI描画メソッド群 ...
		void drawHUD();
		void drawRightGrowthSlots(float scale);
		void drawLeftStatusPanel(float scale);
		void drawCenterMessage(float scale);
		void drawStatusPanel();
		void drawBottomActionBar();
		void drawAura(); // 新設：オーラ描画用

		// ... ユーティリティ ...
		float getUIScale();
		void executeCommand(CommandType type);
		void updateCamera();
		void setupLighting();
		void spawn2DEffect(ParticleType type);

		// --- スキル処理 ---
		void upgradeGrowth();
		void upgradeResist();
		void upgradeCatalyst();
		void checkEvolution();

		// --- システム変数 ---
		ofJson config;
		ofTrueTypeFont mainFont;
		GameState state;
		int hoveredSkillIndex = -1;
		vector<AuraBeam> auraBeams; // Constants.hの定義を使用

		// ... オブジェクト ...
		Tree myTree;
		Weather weather;
		Ground ground;
		ofEasyCam cam;
		ofLight light;
		vector<Particle> particles;
		vector<Particle2D> particles2D;

		// --- GUI ---
		ofxPanel gui;
		ofParameter<int> growthLevel, chaosResistLevel, bloomCatalystLevel;
		ofxButton btnGrowth, btnResist, btnCatalyst;

		void drawControlPanel();
		void drawViewModeOverlay();
		void drawDebugOverlay();
		void drawDualParamBar(string label, float x, float y, float w, float currentRatio, float maxRatio, ofColor col);
		// GUI
		int hoveredButtonIndex = -1;

		void processCommand(int key);
		void spawnBloomParticles();

		// --- システム変数と設定 ---
		float camAutoRotation = 0;
		float visualDepthProgress = 0;
		int lastDepthLevel = 0;
};
</file>

<file path="Tree.cpp">
#include "Tree.h"
void Tree::setup(const ofJson& config) {
    seed = ofRandom(99999);
    auto t = config["tree"];
    s.maxDepth = t.value("max_depth", 6);
    s.expBase = t.value("depth_exp_base", 30.0f);
    s.expPower = t.value("depth_exp_power", 1.6f);
    s.lenScale = t.value("length_visual_scale", 1.5f);
    s.thickScale = t.value("thickness_visual_scale", 0.8f);
    s.branchLenRatio = t.value("branch_length_ratio", 0.75f);
    s.branchThickRatio = t.value("branch_thick_ratio", 0.7f);
    s.baseAngle = t.value("base_angle", 25.0f);
    s.mutationAngleMax = t.value("mutation_angle_max", 45.0f);

    auto c = t["colors"];
    s.trunkHueStart = c.value("trunk_hue_start", 20.0f);
    s.trunkHueEnd = c.value("trunk_hue_end", 160.0f);
    s.leafColor = ofColor(c["leaf"][0], c["leaf"][1], c["leaf"][2], c["leaf"][3]);

	// test value
    //s.twistFactor = 90.0f;
}

void Tree::update(int growthLevel, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType) {
    // 補間ロジックは維持
    bLen = ofLerp(bLen, tLen, 0.1f);
    bThick = ofLerp(bThick, tThick, 0.1f);
    bMutation = ofLerp(bMutation, tMutation, 0.1f);

    maxMutationReached = max(maxMutationReached, bMutation);

    if (depthLevel < s.maxDepth && depthExp >= getExpForDepth(depthLevel + 1)) {
        depthLevel++;
        bNeedsUpdate = true;
    }

    if (bNeedsUpdate || abs(bLen - tLen) > 0.5f || abs(bThick - tThick) > 0.1f) {
        vboMesh.clear();
        ofSetRandomSeed(seed);
        // 構造体 s を経由して描画パラメータを渡す
        buildBranchMesh(bLen * s.lenScale, bThick * s.thickScale, depthLevel, glm::mat4(1.0), chaosResist, bloomLevel, gType, fType);
        bNeedsUpdate = false;
    }
}

void Tree::draw() {
    vboMesh.draw();
}

void Tree::water(float buff, int resilienceLevel, float increment) {
    // デメリット軽減係数 (1レベルにつき15%軽減)
    float penaltyFactor = 1.0f - (resilienceLevel * 0.15f);

    depthExp += 5.0f * buff;

    float lenGain = increment * 2.0f * buff;
    tLen += lenGain;
    totalLenEarned += lenGain; // 累積加算

    // デメリット（太さ減少）に軽減を適用
    tThick = max(2.0f, tThick - (3.0f * penaltyFactor));
    tMutation = max(0.0f, tMutation - 0.1f);
}

void Tree::fertilize(float buff, int resilienceLevel, float increment) {
    float penaltyFactor = 1.0f - (resilienceLevel * 0.15f);

    depthExp += 5.0f * buff;

    // デメリット（長さ減少）に軽減を適用
    tLen = max(10.0f, tLen - (5.0f * penaltyFactor));

    float thickGain = increment * 2.0f * buff;
    tThick += thickGain;
    totalThickEarned += thickGain; // 累積加算

    tMutation = max(0.0f, tMutation - 0.05f);
}

void Tree::kotodama(float buff) {
    depthExp += 5.0f * buff;
    tLen += 10.0f * buff;
    tThick = max(2.0f, tThick - 5.0f);

    float mutGain = 0.2f * buff;
    tMutation = ofClamp(tMutation + mutGain, 0.0f, 1.0f);
    totalMutationEarned += mutGain; // 累積加算
}

void Tree::applyEvolution(GrowthType type) {
    switch (type) {
    case TYPE_ELEGANT:
        s.branchLenRatio = 0.82f;   // より長く伸びる
        s.baseAngle = 18.0f;        // 鋭角でスマートな印象
        s.twistFactor = 15.0f;      // 控えめなねじれ
        break;
    case TYPE_STURDY:
        s.branchThickRatio = 0.85f; // 太さを維持
        s.baseAngle = 35.0f;        // どっしりと広がる
        s.twistFactor = 40.0f;      // 力強いねじれ
        break;
    case TYPE_ELDRITCH:
        s.mutationAngleMax = 65.0f; // 予測不能な広がり
        s.twistFactor = 150.0f;     // 激しい螺旋
        s.trunkHueEnd += 100.0f;    // 色彩変化を拡大
        break;
    }
    bNeedsUpdate = true; // メッシュを再構築
}

glm::mat4 Tree::getNextBranchMatrix(glm::mat4 tipMat, int index, int total, float angleBase) {
    glm::mat4 m = tipMat;
    // Y軸回転で円状に配置
    m = glm::rotate(m, glm::radians(index * (360.0f / total)), glm::vec3(0, 1, 0));
    // 外側へ倒す回転（カオス度による揺らぎ）
    float wobble = ofRandom(-10, 10) * bMutation;
    m = glm::rotate(m, glm::radians(angleBase + wobble), glm::vec3(0, 0, 1));
    return m;
}

void Tree::buildBranchMesh(float length, float thickness, int depth, glm::mat4 mat, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType) {
    if (depth < 0) return;

    // 現在の枝（幹）をメッシュに追加
    addStemToMesh(thickness, thickness * s.branchThickRatio, length, mat, chaosResist, depth, gType);

    // 枝の先端の行列を計算
    glm::mat4 tipMat = glm::translate(mat, glm::vec3(0, length, 0));

    // --- 装飾（葉・花）のロジック ---
    float bloomThreshold = 0.4f - (bloomLevel * 0.05f);
    bool isBloomed = (maxMutationReached > bloomThreshold);

    if (depth == 0 && (isBloomed || fType != FLOWER_NONE)) {
        addFlowerToMesh(thickness, tipMat, fType);
    }
    else if (depth <= 1) {
        addLeafToMesh(thickness, tipMat);
    }

    // --- 次の枝への再帰 ---
    int numBranches = (depth < 2) ? 2 : 3;
    float angleBase = 25.0f + (bMutation * 45.0f); // カオス度で分岐角が広がる

    for (int i = 0; i < numBranches; i++) {
        glm::mat4 childMat = getNextBranchMatrix(tipMat, i, numBranches, angleBase);
        buildBranchMesh(length * s.branchLenRatio, thickness * s.branchThickRatio, depth - 1, childMat, chaosResist, bloomLevel, gType, fType);
    }
}

void Tree::addStemToMesh(float r1, float r2, float h, glm::mat4 mat, int chaosResist, int depth, GrowthType gType) {
    int segments = (depth <= 4) ? 3 : 5; // LOD: 深い枝ほど角数を減らす
    int subdivisions = 4;                // 縦方向の分割数
    int numRings = subdivisions + 1;

    // --- 色の計算 ---
    float timeShift = ofGetElapsedTimef() * 20.0f;
    if (gType == TYPE_ELDRITCH) {
        timeShift = ofGetElapsedTimef() * 100.0f; // Eldritchは激しく色が動く
    }
    float hueBase = ofMap(bMutation, 0, 1, s.trunkHueStart, s.trunkHueEnd);
    float finalHue = fmod(hueBase + timeShift + (depth * 10), 255.0f);
    ofColor col = ofColor::fromHsb(finalHue, 160, 180 + (depth * 10));
    
    float collapseThreshold = 0.9f + (chaosResist * 0.02f);
    // 法線変換用の行列
    glm::mat3 normalMatrix = glm::inverseTranspose(glm::mat3(mat));

    // 現在のVBOの頂点開始インデックスを記録
    int startIndex = vboMesh.getNumVertices();

    // 1. 頂点と法線の生成
    for (int ring = 0; ring < numRings; ring++) {
        float ratio = (float)ring / subdivisions;
        float currentR = ofLerp(r1, r2, ratio); // テーパリング
        float currentY = h * ratio;

        // 進化タイプや設定に応じた「ねじれ」の適用
        float twistAngle = glm::radians(s.twistFactor * ratio);

        for (int i = 0; i < segments; i++) {
            float angle = (i * TWO_PI / segments) + twistAngle;
            glm::vec3 unitPos(cos(angle), 0, sin(angle));

            // 頂点座標（ローカル）
            glm::vec4 p(unitPos.x * currentR, currentY, unitPos.z * currentR, 1);

            // カオス度が高い場合の頂点ノイズ（最上段に近いほど強く揺らす）
            if (maxMutationReached > 0.5f && ring > 0) {
                float nStr = ofMap(maxMutationReached, 0.5, 1.0, 0, 120.0f, true) * ratio;
                p.x += ofSignedNoise(p.x * 0.1, p.y * 0.1, ofGetElapsedTimef()) * nStr;
                p.z += ofSignedNoise(p.z * 0.1, p.y * 0.1, ofGetElapsedTimef() + 10) * nStr;
            }

            // VBOへの登録
            vboMesh.addVertex(glm::vec3(mat * p));
            vboMesh.addNormal(normalMatrix * unitPos); // 簡易法線
            vboMesh.addColor(col);
        }
    }

    // 2. インデックスの生成（面を貼る）
    for (int ring = 0; ring < subdivisions; ring++) {
        for (int i = 0; i < segments; i++) {
            int nextI = (i + 1) % segments;

            // 現在の層の2点
            int v0 = startIndex + (ring * segments) + i;
            int v1 = startIndex + (ring * segments) + nextI;
            // 次の層の2点
            int v2 = startIndex + ((ring + 1) * segments) + i;
            int v3 = startIndex + ((ring + 1) * segments) + nextI;

            // 三角形1
            vboMesh.addIndex(v0);
            vboMesh.addIndex(v1);
            vboMesh.addIndex(v2);

            // 三角形2
            vboMesh.addIndex(v1);
            vboMesh.addIndex(v3);
            vboMesh.addIndex(v2);
        }
    }
}

float Tree::getExpForDepth(int d) {
    if (d <= 0) return 0;
    return s.expBase * pow((float)d, s.expPower);
}

float Tree::getDepthProgress() {
    // 現在のレベルと次のレベルに必要な経験値を取得
    float curThreshold = getExpForDepth(depthLevel);
    float nxtThreshold = getExpForDepth(depthLevel + 1);

    // 0除算を防ぐ
    if (nxtThreshold <= curThreshold) return 1.0f;

    // 現在のレベル内での進捗率を 0.0 ~ 1.0 で返す
    return ofClamp((depthExp - curThreshold) / (nxtThreshold - curThreshold), 0.0f, 1.0f);
}

void Tree::addLeafToMesh(float thickness, glm::mat4 mat) {
    int startIndex = vboMesh.getNumVertices();
    ofColor lCol = s.leafColor;
    float w = thickness * 3.0f;
    float h = thickness * 6.0f;

    // 4頂点 (ひし形)
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, 0, 1)));           // 0: 付け根
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(-w, h * 0.5f, 0, 1)));   // 1: 左
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(w, h * 0.5f, 0, 1)));    // 2: 右
    vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, h, 0, 1)));           // 3: 先端

    for (int i = 0; i < 4; i++) {
        vboMesh.addNormal(glm::normalize(glm::mat3(mat) * glm::vec3(0, 0, 1)));
        vboMesh.addColor(lCol);
    }

    // インデックスで2つの三角形を形成
    vboMesh.addIndex(startIndex + 0); vboMesh.addIndex(startIndex + 1); vboMesh.addIndex(startIndex + 3);
    vboMesh.addIndex(startIndex + 0); vboMesh.addIndex(startIndex + 2); vboMesh.addIndex(startIndex + 3);
}

void Tree::addFlowerToMesh(float thickness, glm::mat4 mat, FlowerType type) {
    if (type == FLOWER_NONE) return;

    int startIndex = vboMesh.getNumVertices();
    ofColor fCol = s.flowerColor;

    if (type == FLOWER_CRYSTAL) {
        // 【Type A: 結晶】 放射状に広がる鋭い三角形
        float r = thickness * 4.0f;
        int numPoints = 6;
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, 0, 1))); // 中心
        vboMesh.addColor(fCol); vboMesh.addNormal(glm::vec3(0, 1, 0));

        for (int i = 0; i < numPoints; i++) {
            float ang = i * TWO_PI / numPoints;
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(cos(ang) * r, thickness, sin(ang) * r, 1)));
            vboMesh.addColor(fCol); vboMesh.addNormal(glm::vec3(0, 1, 0));

            vboMesh.addIndex(startIndex);
            vboMesh.addIndex(startIndex + 1 + i);
            vboMesh.addIndex(startIndex + 1 + (i + 1) % numPoints);
        }
    }
    else if (type == FLOWER_PETAL) {
        // 【Type B: 花弁】 5枚の柔らかい面
        float r = thickness * 3.5f;
        for (int i = 0; i < 5; i++) {
            int pStart = vboMesh.getNumVertices();
            float ang = i * TWO_PI / 5;
            // 簡易的な花びら1枚(三角形)
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, 0, 1)));
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(cos(ang - 0.3) * r, r * 0.5, sin(ang - 0.3) * r, 1)));
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(cos(ang + 0.3) * r, r * 0.5, sin(ang + 0.3) * r, 1)));
            for (int k = 0; k < 3; k++) { vboMesh.addColor(fCol); vboMesh.addNormal(glm::vec3(0, 1, 0)); }
            vboMesh.addIndex(pStart); vboMesh.addIndex(pStart + 1); vboMesh.addIndex(pStart + 2);
        }
    }
    else if (type == FLOWER_SPIRIT) {
        // 【Type C: 霊魂】 ゆらゆら揺れる尖った火の玉
        float r = thickness * 2.5f;
        float time = ofGetElapsedTimef() * 3.0f;
        float offset = ofSignedNoise(time) * 15.0f;

        vboMesh.addVertex(glm::vec3(mat * glm::vec4(offset, r * 5.0f, 0, 1))); // 尖った先端
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(-r, 0, -r, 1)));
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(r, 0, -r, 1)));
        vboMesh.addVertex(glm::vec3(mat * glm::vec4(0, 0, r, 1)));

        for (int k = 0; k < 4; k++) { vboMesh.addColor(ofColor(150, 200, 255, 180)); vboMesh.addNormal(glm::vec3(0, 1, 0)); }
        // 四面体のインデックス
        int idxs[] = { 0,1,2, 0,2,3, 0,3,1 };
        for (int id : idxs) vboMesh.addIndex(startIndex + id);
    }
}

void Tree::addJointToMesh(float radius, glm::mat4 mat, ofColor col, int depth) {
    // LOD: 先端の細い枝ほどポリゴンを削る
    int rings = (depth <= 2) ? 4 : 6;
    int sectors = (depth <= 2) ? 4 : 6;
    int startIndex = vboMesh.getNumVertices();
    glm::mat3 normalMatrix = glm::inverseTranspose(glm::mat3(mat));

    for (int r = 0; r <= rings; r++) {
        float phi = PI * (float)r / rings;
        for (int s = 0; s <= sectors; s++) {
            float theta = TWO_PI * (float)s / sectors;

            glm::vec3 unitPos(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(unitPos * radius, 1.0)));
            vboMesh.addNormal(normalMatrix * unitPos);
            vboMesh.addColor(col);
        }
    }

    for (int r = 0; r < rings; r++) {
        for (int s = 0; s < sectors; s++) {
            int v0 = startIndex + r * (sectors + 1) + s;
            int v1 = v0 + 1;
            int v2 = startIndex + (r + 1) * (sectors + 1) + s;
            int v3 = v2 + 1;
            vboMesh.addIndex(v0); vboMesh.addIndex(v1); vboMesh.addIndex(v2);
            vboMesh.addIndex(v1); vboMesh.addIndex(v3); vboMesh.addIndex(v2);
        }
    }
}

void Tree::reset() {
    // 育成状態の初期化
    dayCount = 1;
    maxMutationReached = 0;
    depthExp = 0;
    depthLevel = 0;
    // パラメータを初期値へ
    bLen = 0; tLen = 10;
    bThick = 0; tThick = 2;
    bMutation = 0; tMutation = 0;

    // 木の形状シードを再生成
    seed = ofRandom(99999);
    vboMesh.clear();
    bNeedsUpdate = true;
}

int Tree::getCurrentDepth() {
    return depthLevel;
}
</file>

<file path="Tree.h">
#pragma once
#include "ofMain.h"
#include "Constants.h"

class Tree {
public:
    void setup(const ofJson& config); 
    void update(int growthLevel, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType);
    void draw();
    void reset();

    void water(float buff, int resilienceLevel, float increment);      // 長さを伸ばし、カオス度を下げる
    void fertilize(float buff, int resilienceLevel, float increment);  // 太さを増し、カオス度を下げる
    void kotodama(float buff);   // カオス度を上げる
    void applyEvolution(GrowthType type);
    void incrementDay() { if (dayCount < 50) dayCount++; }
    void addDebugExp(float amt) { depthExp += amt; }
    void setNeedsUpdate() { bNeedsUpdate = true; }

    // --- アクセサ・ユーティリティ ---
    float getLen() { return bLen; }
    float getThick() { return bThick; }
    float getMaxMutation() { return maxMutationReached; }
    float getCurMutation() { return bMutation; }
    float getDepthExp() { return depthExp; }
    int getDepthLevel() { return depthLevel; }
    int getCurrentDepth();
    float getTotalLenEarned() { return totalLenEarned; }
    float getTotalThickEarned() { return totalThickEarned; }
    float getTotalMutationEarned() { return totalMutationEarned; }
    int getDayCount() { return dayCount; }
    int getSeed() { return seed; }
    float getDepthProgress();
    ofVboMesh& getVboMesh() { return vboMesh; }

private:
    // 内部ロジック：座標変換とメッシュ構築
    glm::mat4 getNextBranchMatrix(glm::mat4 tipMat, int index, int total, float angleBase);
    void buildBranchMesh(float length, float thickness, int depth, glm::mat4 mat, int chaosResist, int bloomLevel, GrowthType gType, FlowerType fType);
    void addStemToMesh(float r1, float r2, float h, glm::mat4 mat, int chaosResist,int depth, GrowthType gType);
    void addFlowerToMesh(float thickness, glm::mat4 mat, FlowerType type);
    void addLeafToMesh(float thickness, glm::mat4 mat);
    void addJointToMesh(float radius, glm::mat4 mat, ofColor col, int depth);
    float getExpForDepth(int d);

    // --- 育成パラメータ (b:現在値, t:目標値) ---
    float bLen = 0, bThick = 0, bMutation = 0;
    float tLen = 10, tThick = 2, tMutation = 0;
    float depthExp = 0;
    int depthLevel = 0;
    float totalLenEarned = 0;
    float totalThickEarned = 0;
    float totalMutationEarned = 0;

    // --- 状態管理 ---
    ofVboMesh vboMesh; 
    int seed;
    int dayCount = 1;
    float maxMutationReached = 0;
    float lastMutation = 0;
    bool bNeedsUpdate = true;

    // --- JSON定数 ---
    TreeSettings s;
    /*int maxDepthConfig, currentDepth = 0;
    float depthExpBase, depthExpPower;
    float lengthVisualScale, thickVisualScale;
    float branchLenRatio, branchThickRatio;
    float baseAngle, mutationAngleMax;
    float trunkHueStart, trunkHueEnd;
    ofColor leafColor, flowerColor;*/
};
</file>

<file path="src/ofApp.cpp">
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetFrameRate(60);
    ofEnableDepthTest();
    ofEnableSmoothing();

    config = ofLoadJson("settings.json");
    if (config.empty()) {
        ofLogError("ofApp") << "settings.json not found! Using hardcoded defaults.";
        config["game"]["water_increment"] = 15.0;
        config["game"]["fertilize_increment"] = 8.0;
        config["camera"]["height_factor"] = 3.5;
    }
    mainFont.load("verdana.ttf", 10, true, true);

    // UI設定の読み込み
    auto ui = config["ui"];
    state.ui.labelWater = ui["labels"].value("water", "WATER");
    state.ui.labelFertilizer = ui["labels"].value("fertilizer", "FERTILIZE");
    state.ui.labelKotodama = ui["labels"].value("kotodama", "KOTODAMA");

    state.ui.colElegant.set(180, 220, 255); // 暫定。後ほどJSONから取得
    state.ui.colSturdy.set(150, 255, 100);
    state.ui.colEldritch.set(255, 50, 100);

    auto btn = ui["button"];
    state.ui.btnW = btn.value("width", 160.0f);
    state.ui.btnH = btn.value("height", 50.0f);
    state.ui.btnMargin = btn.value("margin", 20.0f);
    state.ui.btnBottomOffset = btn.value("bottom_offset", 60.0f);

    auto col = ui["colors"];
    state.ui.colIdle.set(col["idle"][0], col["idle"][1], col["idle"][2], col["idle"][3]);
    state.ui.colHover.set(col["hover"][0], col["hover"][1], col["hover"][2], col["hover"][3]);
    state.ui.colActive.set(col["active"][0], col["active"][1], col["active"][2], col["active"][3]);
    state.ui.colLocked.set(col["locked"][0], col["locked"][1], col["locked"][2], col["locked"][3]);
    state.ui.colText.set(col["text"][0], col["text"][1], col["text"][2], col["text"][3]);

    state.ui.cooldownDuration = ui.value("cooldown_time", 1.0f);
    state.ui.statusTop = ui["status_pos"].value("top", 30.0f);
    state.ui.statusRight = ui["status_pos"].value("right", 30.0f);

    // state構造体の初期化
    state.skillPoints = 3;
    state.maxDays = config["game"].value("max_days", 50);
    state.bGameEnded = false;
    state.bViewMode = false;
    state.bShowDebug = false;

    myTree.setup(config);
    lastDepthLevel = myTree.getDepthLevel();

    weather.setup();
    ground.setup();

    // --- GUI初期化 ---
    gui.setup("Skill & Debug", "settings.xml", 20, 150);
    gui.add(growthLevel.set("Growth Efficiency", 0, 0, 5));
    gui.add(chaosResistLevel.set("Chaos Resistance", 0, 0, 5));
    gui.add(bloomCatalystLevel.set("Bloom Catalyst", 0, 0, 5));

    gui.add(btnGrowth.setup("Upgrade Growth (1pt)"));
    gui.add(btnResist.setup("Upgrade Resistance (1pt)"));
    gui.add(btnCatalyst.setup("Upgrade Bloom (1pt)"));

    btnGrowth.addListener(this, &ofApp::upgradeGrowth);
    btnResist.addListener(this, &ofApp::upgradeResist);
    btnCatalyst.addListener(this, &ofApp::upgradeCatalyst);

    ofEnableLighting();
    light.setup();
    cam.setDistance(400);
    cam.setGlobalPosition(ofVec3f(0, 150, 150));
    cam.lookAt(ofVec3f(0, 0, 0));
    cam.setNearClip(0.1);
    cam.setFarClip(20000);
    cam.setTarget(ofVec3f(0, 0, 0));
    cam.disableMouseInput();
}

//--------------------------------------------------------------
void ofApp::update() {
    if (state.actionCooldown > 0) {
        state.actionCooldown -= ofGetLastFrameTime();
        if (state.actionCooldown < 0) state.actionCooldown = 0;
    }
    // 終了判定
    if (myTree.getDayCount() >= state.maxDays && !state.bGameEnded) {
        state.bGameEnded = true;
        // 称号決定
        if (myTree.getLen() > 200 && myTree.getMaxMutation() < 0.3) state.finalTitle = "Elegant Giant";
        else if (myTree.getMaxMutation() > 0.8) state.finalTitle = "Herald of Chaos";
        else state.finalTitle = "Great Spirit Tree";
    }

    if (state.bShowDebug && state.bInfiniteSkills) {
        state.skillPoints = 99;
    }

    myTree.update(growthLevel, chaosResistLevel, bloomCatalystLevel, state.currentType, state.currentFlowerType);
    weather.update();

    updateCamera();

    visualDepthProgress = ofLerp(visualDepthProgress, myTree.getDepthProgress(), 0.1f);

    // パーティクル更新
    for (auto& p : particles) p.update();
    ofRemove(particles, [](Particle& p) { return p.life <= 0; });
    for (auto& p : particles2D) p.update();
    ofRemove(particles2D, [](Particle2D& p) { return p.life <= 0; });
    if (weather.state == RAINY && ofGetFrameNum() % 3 == 0) {
        spawn2DEffect(P_RAIN_SPLASH);
    }

    // レベルアップの検知ロジック
    int currentLvl = myTree.getDepthLevel();
    if (currentLvl > lastDepthLevel) {
        state.barState = BAR_LEVEL_UP_FLASH; // バーの発光アニメーション開始
        state.barFlashTimer = 0;
        lastDepthLevel = currentLvl;
    }
    // --- バーのアニメーション管理 ---
    if (state.barState == BAR_LEVEL_UP_FLASH) {
        state.barFlashTimer += ofGetLastFrameTime();
        if (state.barFlashTimer > 0.4f) { // 0.4秒発光を維持
            state.barState = BAR_RESET_WAIT;
            state.barFlashTimer = 0;
            state.levelUpBubbleTimer = 1.5f; // 「LEVEL UP!」表示開始
        }
    }
    else if (state.barState == BAR_RESET_WAIT) {
        visualDepthProgress = ofLerp(visualDepthProgress, 0, 0.2f);
        if (visualDepthProgress < 0.01f) {
            visualDepthProgress = 0;
            state.barState = BAR_IDLE;
        }
    }
    else {
        visualDepthProgress = ofLerp(visualDepthProgress, myTree.getDepthProgress(), 0.1f);
    }

    // --- オーラと演出タイマーの更新 ---
    if (state.auraTimer > 0) state.auraTimer -= ofGetLastFrameTime();
    if (state.levelUpBubbleTimer > 0) state.levelUpBubbleTimer -= ofGetLastFrameTime();
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofBackground(weather.getBgFromConfig(config));

    ofEnableDepthTest();
    ofEnableLighting();
    setupLighting();

    cam.begin();
    ground.draw();
    myTree.draw();
    for (auto& p : particles) p.draw();
    cam.end();

    light.disable();
    ofDisableLighting();
    ofDisableDepthTest();

    for (auto& p : particles2D) p.draw();
    weather.draw2D();

    if (state.bViewMode) drawViewModeOverlay();
    else drawHUD();

    if (state.bShowDebug) drawDebugOverlay();
}
void ofApp::updateCamera() {
    if (state.bViewMode) return;

    float hFactor = config["camera"].value("height_factor", 3.5f);
    float treeH = myTree.getLen() * hFactor;
    float targetDist, lookAtY;

    if (state.bGameEnded) {
        camAutoRotation += 0.4f;
        targetDist = myTree.getLen() * 5.0f;
        lookAtY = treeH * 0.4f;

        float rad = ofDegToRad(camAutoRotation);
        cam.setPosition(sin(rad) * targetDist, lookAtY + 50, cos(rad) * targetDist);
        cam.lookAt(glm::vec3(0, lookAtY, 0));
    }
    else {
        camAutoRotation += 0.2f;
        targetDist = max(600.0f, treeH * 1.5f);
        lookAtY = treeH * 0.4f;

        float rad = ofDegToRad(camAutoRotation);
        glm::vec3 targetPos(sin(rad) * targetDist, lookAtY + 100, cos(rad) * targetDist);

        cam.setTarget(glm::vec3(0, lookAtY, 0));
        cam.setPosition(targetPos);
        cam.lookAt(glm::vec3(0, lookAtY, 0));
    }
}

void ofApp::spawnBloomParticles() {
    for (int i = 0; i < 30; i++) {
        Particle p;
        p.setup(glm::vec3(0, myTree.getLen() * 2, 0),
            glm::vec3(ofRandom(-2, 2), ofRandom(2, 5), ofRandom(-2, 2)),
            ofColor(255, 150, 200));
        particles.push_back(p);
    }
}

//--------------------------------------------------------------
void ofApp::setupLighting() {
    // 天候ごとのライティング・プリセット
    switch (weather.state) {
    case SUNNY:
        light.setDirectional();
        light.setDiffuseColor(ofColor(255, 250, 230));
        light.setOrientation(glm::vec3(-45, -45, 0));
        break;
    case MOONLIGHT:
        light.setPointLight();
        light.setDiffuseColor(ofColor(120, 150, 255));
        light.setPosition(0, 500, 200);
        break;
    case RAINY:
        light.setPointLight();
        light.setDiffuseColor(ofColor(50, 60, 80));
        light.setPosition(0, 800, 0);
        break;
    }
    light.enable();
}

//--------------------------------------------------------------
float ofApp::getUIScale() {
    float baseW = 1024.0f; // 開発時の基準幅
    float baseH = 768.0f;  // 開発時の基準高さ
    // 縦横の比率のうち、小さい方に合わせることで画面外へのはみ出しを防ぐ
    return glm::min(ofGetWidth() / baseW, ofGetHeight() / baseH);
}

void ofApp::drawHUD() {
    float scale = getUIScale();
    ofPushMatrix();
    ofScale(scale, scale);

    // スキルパネル（デバッグ表示がONの時のみ）
    if (state.bShowDebug) {
        drawControlPanel();
    }

    ofPopMatrix(); // 一旦戻す（個別に座標計算するため）

    drawLeftStatusPanel(scale);  // 天候、進化印、デバッグ
    drawRightGrowthSlots(scale); // スキルボタン
    drawCenterMessage(scale);    // メッセージ、吹き出し

    drawStatusPanel();     // 右上へ
    drawBottomActionBar(); // 下部中央へ
}

string getFlowerName(FlowerType type) {
    switch (type) {
    case FLOWER_CRYSTAL: return "CRYSTAL";
    case FLOWER_PETAL: return "PETAL";
    case FLOWER_SPIRIT: return "SPIRIT";
    default: return "NONE";
    }
}


void ofApp::drawLeftStatusPanel(float scale) {
    ofPushMatrix();
    ofScale(scale, scale);
    ofTranslate(20, 20);

    // 0. 日数表示
    ofSetColor(255);
    string dayStr = "DAY: " + ofToString(myTree.getDayCount()) + " / " + ofToString(state.maxDays);
    if (state.bTimeFrozen) dayStr += " (FROZEN)";
    mainFont.drawString(dayStr, 0, 20);

    // 1. 天候バフ情報 (Y座標を 50, 70 に離す)
    ofSetColor(200, 230, 255);
    mainFont.drawString("WEATHER: " + weather.getName(), 0, 50);
    ofSetColor(255, 255, 0);
    string buff = (weather.state == SUNNY) ? "Buff: Water+" : (weather.state == RAINY) ? "Buff: Fertilizer+" : "Buff: Kotodama+";
    mainFont.drawString(buff, 0, 70);

    // 2. 進化達成の印 (Y座標 110 から開始)
    float symbolY = 110;
    auto drawSym = [&](bool active, string sym, ofColor col, string label) {
        ofSetColor(active ? col : ofColor(80));
        mainFont.drawString(sym + " " + label, 0, symbolY);
        symbolY += 30;
        };
    drawSym(state.evo.hasEvolvedType && state.currentType == TYPE_ELEGANT, "◇", state.ui.colElegant, "ELEGANT");
    drawSym(state.evo.hasEvolvedType && state.currentType == TYPE_STURDY, "□", state.ui.colSturdy, "STURDY");
    drawSym(state.evo.hasEvolvedType && state.currentType == TYPE_ELDRITCH, "◎", state.ui.colEldritch, "ELDRITCH");

    drawSym(state.evo.hasEvolvedFlower, "✿", ofColor(255, 150, 200), "BLOOM: " + getFlowerName(state.currentFlowerType));

    // 3. デバッグ設定のステータス表示
    if (state.bShowDebug) {
        ofSetColor(255, 100, 100);
        float dy = symbolY + 20;
        mainFont.drawString(">> DEBUG ACTIVE <<", 0, dy);
        mainFont.drawString(state.bInfiniteSkills ? "[P] INF SKILLS: ON" : "[P] INF SKILLS: OFF", 0, dy + 25);
        mainFont.drawString("[+] ADD EXP (Test LevelUp)", 0, dy + 50);
    }
    ofPopMatrix();
}

void ofApp::drawRightGrowthSlots(float scale) {
    float panelW = 200;
    float btnH = 60;
    float spacing = 70;

    ofPushMatrix();
    ofTranslate(ofGetWidth() - (panelW * scale) - 20, ofGetHeight() / 2 - (spacing * 1.5f) * scale);
    ofScale(scale, scale);

    hoveredSkillIndex = -1; // リセット
    // マウス座標をUI空間に変換
    float mx = (ofGetMouseX() - (ofGetWidth() - (panelW * scale) - 20)) / scale;
    float my = (ofGetMouseY() - (ofGetHeight() / 2 - (spacing * 1.5f) * scale)) / scale;

    string names[] = { "GROWTH", "RESIST", "CATALYST" };
    int levels[] = { growthLevel, chaosResistLevel, bloomCatalystLevel };
    int cost = 1;

    for (int i = 0; i < 3; i++) {
        float by = i * spacing;
        bool isHovered = (mx >= 0 && mx <= panelW && my >= by && my <= by + btnH);
        bool canAfford = (state.skillPoints >= cost);

        if (isHovered) {
            hoveredSkillIndex = i; // ホバー中のインデックスを保持
        }

        // 色の決定
        ofColor bCol = canAfford ? ofColor(100, 150, 255, 180) : ofColor(60, 150);
        if (isHovered && canAfford) bCol = ofColor(150, 200, 255, 255); // ホバー時は明るく

        ofSetColor(bCol);
        ofDrawRectRounded(0, by, panelW, btnH, 5);

        ofSetColor(255);
        mainFont.drawString(names[i], 10, by + 25);
        mainFont.drawString("LV." + ofToString(levels[i]), 10, by + 48);
        mainFont.drawString("COST: " + ofToString(cost), panelW - 80, by + 48);
    }
    // ... スキルポイント表示 ...
    ofSetColor(255, 200, 0);
    mainFont.drawString("SKILL POINTS: " + ofToString(state.skillPoints), 0, -20);
    ofPopMatrix();
}

// 画面中央のメッセージ（レベルアップ吹き出し・進化通知）を描画
void ofApp::drawCenterMessage(float scale) {
    ofPushStyle();
    ofPushMatrix();
    // 基準解像度に合わせてスケーリング
    ofScale(scale, scale);

    // 1. レベルアップの吹き出し ("LEVEL UP!")
    if (state.levelUpBubbleTimer > 0) {
        float alpha = ofMap(state.levelUpBubbleTimer, 0, 1.5, 0, 255, true);
        string msg = "LEVEL UP!";
        float tw = mainFont.stringWidth(msg);

        // 木の高さに依存せず、画面内の見やすい位置(中央より上)に固定
        float tx = (ofGetWidth() / scale) * 0.5f - tw * 0.5f;
        float ty = (ofGetHeight() / scale) * 0.35f; // 画面上部から35%の位置

        ofSetColor(255, 255, 255, alpha * 0.9);
        ofDrawRectRounded(tx - 20, ty - 30, tw + 40, 45, 10);
        ofDrawTriangle(tx + tw * 0.5f - 10, ty + 15, tx + tw * 0.5f + 10, ty + 15, tx + tw * 0.5f, ty + 35);

        ofSetColor(0, 0, 0, alpha);
        mainFont.drawString(msg, tx, ty + 5);
    }

    // 2. 進化完了メッセージ ("EVOLUTION COMPLETE")
    // Day 20 または Day 40 の当日のみ、画面中央に大きく表示
    int currentDay = myTree.getDayCount();
    if (currentDay == 20 || currentDay == 40) {
        // クールタイム中（アクション実行直後）に強調表示
        float alpha = ofMap(state.actionCooldown, 0, state.ui.cooldownDuration, 100, 255, true);

        string evoMsg = "EVOLUTION COMPLETE";
        float tw = mainFont.stringWidth(evoMsg);
        float tx = (ofGetWidth() / scale) * 0.5f - tw * 0.5f;
        float ty = (ofGetHeight() / scale) * 0.5f;

        // 文字の背後に帯状の背景
        ofSetColor(0, 0, 0, alpha * 0.6);
        ofDrawRectangle(0, ty - 40, ofGetWidth() / scale, 60);

        // 進化タイプに応じた色で強調
        ofColor evoCol = ofColor(255, 255, 0); // デフォルト
        if (currentDay == 20) {
            if (state.currentType == TYPE_ELEGANT) evoCol = state.ui.colElegant;
            else if (state.currentType == TYPE_STURDY) evoCol = state.ui.colSturdy;
            else if (state.currentType == TYPE_ELDRITCH) evoCol = state.ui.colEldritch;
        }

        ofSetColor(evoCol, alpha);
        mainFont.drawString(evoMsg, tx, ty);
    }

    ofPopMatrix();
    ofPopStyle();
}

// ステータスパネル（プログレスバー）の描画
void ofApp::drawStatusPanel() {
    float scale = getUIScale();
    float pW = 320, pH = 180;

    ofPushMatrix();
    // JSONの設定値に基づいて右上に配置
    float tx = ofGetWidth() - (pW * scale) - (state.ui.statusRight * scale);
    float ty = state.ui.statusTop * scale;
    ofTranslate(tx, ty);
    ofScale(scale, scale);

    // 背景
    ofSetColor(0, 160);
    ofDrawRectRounded(0, 0, pW, pH, 10);

    // パラメータバー描画（既存ロジックを流用）
    drawDualParamBar("Depth Level " + ofToString(myTree.getDepthLevel()), 25, 45, 270, visualDepthProgress, 0, ofColor(120, 255, 100));
    drawDualParamBar("Total Length", 25, 95, 270, ofClamp(myTree.getLen() / 400.0f, 0, 1), 0, ofColor(100, 200, 255));
    drawDualParamBar("Chaos (Cur / Max)", 25, 145, 270, myTree.getCurMutation(), myTree.getMaxMutation(), ofColor(255, 80, 150));
    ofPopMatrix();
}

void ofApp::drawBottomActionBar() {
    float scale = getUIScale();
    float btnW = state.ui.btnW;
    float btnH = state.ui.btnH;
    float margin = state.ui.btnMargin;
    int numBtns = 3;
    float totalW = (btnW * numBtns) + (margin * (numBtns - 1));

    ofPushMatrix();
    ofTranslate(ofGetWidth() / 2 - (totalW * scale) / 2, ofGetHeight() - (state.ui.btnBottomOffset * scale) - (btnH * scale));
    ofScale(scale, scale);

    string labels[] = { state.ui.labelWater, state.ui.labelFertilizer, state.ui.labelKotodama };
    CommandType types[] = { CMD_WATER, CMD_FERTILIZER, CMD_KOTODAMA };

    hoveredButtonIndex = -1;
    float mx = ofGetMouseX() / scale - (ofGetWidth() / 2 / scale - totalW / 2);
    float my = ofGetMouseY() / scale - (ofGetHeight() / scale - state.ui.btnBottomOffset - btnH);

    for (int i = 0; i < numBtns; i++) {
        float bx = i * (btnW + margin);
        bool isHovered = (mx >= bx && mx <= bx + btnW && my >= 0 && my <= btnH);

        // 色の決定
        ofColor bCol;
        if (state.actionCooldown > 0) bCol = state.ui.colLocked;
        else if (isHovered) {
            bCol = state.ui.colHover;
            hoveredButtonIndex = i;
        }
        else bCol = state.ui.colIdle;

        // ボタン本体
        ofSetColor(bCol);
        ofDrawRectRounded(bx, 0, btnW, btnH, 5);

        // テキスト
        ofSetColor(state.ui.colText);
        float tw = mainFont.stringWidth(labels[i]);
        mainFont.drawString(labels[i], bx + (btnW - tw) / 2, btnH / 2 + 7);

        // クールタイムゲージ（ボタンの下側に細く表示）
        if (state.actionCooldown > 0) {
            ofSetColor(state.ui.colActive);
            float progress = state.actionCooldown / state.ui.cooldownDuration;
            ofDrawRectangle(bx, btnH - 4, btnW * progress, 4);
        }
    }
    ofPopMatrix();
}

void ofApp::drawDualParamBar(string label, float x, float y, float w, float currentRatio, float maxRatio, ofColor col) {
    ofPushStyle();
    // 動的ラベル背景（文字の長さにフィット）
    float tw = mainFont.stringWidth(label) + 12;
    ofSetColor(0, 220);
    ofDrawRectangle(x - 2, y - 22, tw, 18);
    ofSetColor(255);
    mainFont.drawString(label, x + 3, y - 8);
    // バー背景
    ofSetColor(40);
    ofDrawRectangle(x, y, w, 14);
    // 最大値（記憶）の薄い表示
    if (maxRatio > 0) {
        ofSetColor(col, 60);
        ofDrawRectangle(x, y, w * maxRatio, 14);
    }
    // 現在値
    ofSetColor(col, 255);
    ofDrawRectangle(x, y, w * currentRatio, 14);
    ofPopStyle();
}

// コントロールパネルの描画
void ofApp::drawControlPanel() {
    float scale = glm::min(ofGetWidth() / 1024.0f, ofGetHeight() / 768.0f);
    ofPushStyle();
    ofPushMatrix();

    float panelW = 240; // 少し幅を広げる
    float panelH = 380; // 情報量に合わせて高くする
    ofTranslate(20 * scale, 120 * scale);

    // 背景
    ofSetColor(0, 0, 0, 180);
    ofDrawRectRounded(0, 0, panelW, panelH, 8);

    // --- 詳細ステータス表示 ---
    ofSetColor(255);
    int ty = 25;
    mainFont.drawString("=== TREE STATUS ===", 15, ty); ty += 25;
    ofSetColor(200, 255, 200);
    mainFont.drawString("Growth Lvl:  " + ofToString(growthLevel), 15, ty); ty += 18;
    ofSetColor(200, 200, 255);
    mainFont.drawString("Resist Lvl:  " + ofToString(chaosResistLevel), 15, ty); ty += 18;
    ofSetColor(255, 200, 200);
    mainFont.drawString("Catalyst:    " + ofToString(bloomCatalystLevel), 15, ty); ty += 25;

    // 天候ボーナス表示
    ofSetColor(255, 255, 0);
    string buffInfo = "Weather Buff: ";
    if (weather.state == SUNNY) buffInfo += "Water+";
    else if (weather.state == RAINY) buffInfo += "Fertilizer+";
    else if (weather.state == MOONLIGHT) buffInfo += "Kotodama+";
    mainFont.drawString(buffInfo, 15, ty); ty += 25;

    // 残り日数
    int maxDays = config["game"].value("max_days", 50);
    int daysLeft = maxDays - myTree.getDayCount();
    ofSetColor(255);
    mainFont.drawString("Days to Limit: " + ofToString(daysLeft), 15, ty); ty += 30;

    // ofxGuiの位置調整
    gui.setPosition(30, ty);
    gui.draw();

    // コマンドガイド
    ofSetColor(200);
    string cmds = "[1] Water  [2] Fertilizer\n[3] Kotodama\n\n'V' ViewMode  'D' Debug\n'R' Reset";
    mainFont.drawString(cmds, 15, panelH - 90);

    ofPopMatrix();
    ofPopStyle();
}

void ofApp::drawDebugOverlay() {
    float scale = getUIScale();
    ofPushStyle();
    ofScale(scale, scale);
    string d = "=== DEBUG INFO ===\n";
    d += "FPS: " + ofToString(ofGetFrameRate(), 1) + "\n";
    d += "VBO Vertices: " + ofToString(myTree.getVboMesh().getNumVertices()) + "\n";
    d += "2D Particles: " + ofToString(particles2D.size()) + "\n";
    d += "3D Particles: " + ofToString(particles.size()) + "\n";
    d += "------------------\n";
    d += "Depth: " + ofToString(myTree.getDepthLevel()) + " / " + ofToString(config["tree"].value("max_depth", 8)) + "\n";
    d += "Exp: " + ofToString(myTree.getDepthExp(), 1) + "\n";
    d += "Length: " + ofToString(myTree.getLen(), 1) + " (Target: " + ofToString(myTree.getLen(), 1) + ")\n";
    d += "Thick: " + ofToString(myTree.getThick(), 1) + "\n";
    d += "Mutation: " + ofToString(myTree.getMaxMutation(), 3);
    float dw = 300;
    ofSetColor(0, 200);
    ofDrawRectangle(ofGetWidth() / scale - dw - 20, 20, dw, 190);
    ofSetColor(0, 255, 0);
    mainFont.drawString(d, ofGetWidth() / scale - dw - 10, 40);

    ofPopMatrix();
    ofPopStyle();
}

// View Modeのオーバーレイ
void ofApp::drawViewModeOverlay() {
    ofPushStyle();
    string msg = "VIEW MODE : Orbit(Mouse) / Return('V')";
    float w = msg.length() * 8 + 20;
    ofSetColor(0, 0, 0, 200);
    ofDrawRectangle(ofGetWidth() / 2 - w / 2, ofGetHeight() - 50, w, 30);
    ofSetColor(255);
    ofDrawBitmapString(msg, ofGetWidth() / 2 - w / 2 + 10, ofGetHeight() - 30);
    ofPopStyle();
}

// 演出生成の実装
void ofApp::spawn2DEffect(ParticleType type) {
    int count = (type == P_RAIN_SPLASH) ? 1 : 60;

    for (int i = 0; i < count; i++) {
        Particle2D p;
        p.type = type;

        switch (type) {
        case P_WATER: {
            p.pos = { (float)ofRandomWidth(), -20.0f };
            p.vel = { ofRandom(-3, 3), ofRandom(10, 20) };
            p.color = ofColor(120, 200, 255);
            p.size = ofRandom(3, 8);
            p.decay = ofRandom(0.01, 0.03);
        }break;

        case P_FERTILIZER: {
            p.pos = { (float)ofRandomWidth(), (float)ofGetHeight() + 20.0f };
            p.vel = { ofRandom(-4, 4), ofRandom(-8.0f, -4.0f) };
            p.color = ofColor(180, 255, 100);
            p.size = ofRandom(8, 15);
            p.decay = ofRandom(0.005, 0.015);
        }break;

        case P_KOTODAMA: {
            p.pos = { (float)ofGetWidth() / 2, (float)ofGetHeight() / 2 };
            float angle = ofRandom(TWO_PI);
            float spd = ofRandom(5, 15);
            p.vel = { cos(angle) * spd, sin(angle) * spd };
            p.color = ofColor(200, 160, 255);
            p.size = ofRandom(10, 30);
            p.decay = ofRandom(0.02, 0.04);
        }break;

        case P_RAIN_SPLASH: {
            p.pos = { ofRandomWidth(), ofRandom(ofGetHeight() * 0.8, ofGetHeight()) };
            p.vel = { 0, 0 };
            p.color = ofColor(150, 180, 255, 100);
            p.size = ofRandom(5, 15);
            p.decay = 0.05;
        }break;

        case P_BLOOM: {
            p.pos = { (float)ofGetWidth() / 2.0f + ofRandom(-150, 150),
                      (float)ofGetHeight() / 2.0f + ofRandom(-150, 150) };
            p.vel = { ofRandom(-2, 2), ofRandom(-2, 2) };
            p.color = ofColor(255, 200, 230);
            p.size = ofRandom(2, 4);
            p.decay = 0.02f;
        } break;
        }
        particles2D.push_back(p);
    }
}

void ofApp::drawAura() {
    if (state.auraTimer <= 0) return;

    ofPushStyle();
    ofEnableBlendMode(OF_BLENDMODE_ADD); // 加算合成で光を表現

    // 進化状態に応じた色の決定
    ofColor auraCol = ofColor(255, 255, 200); // デフォルト
    if (state.currentType == TYPE_ELEGANT) auraCol = state.ui.colElegant;
    else if (state.currentType == TYPE_STURDY) auraCol = state.ui.colSturdy;
    else if (state.currentType == TYPE_ELDRITCH) auraCol = state.ui.colEldritch;

    float progress = state.auraTimer / config["ui"]["aura"].value("duration", 1.5f);
    float flicker = (0.7f + 0.3f * sin(ofGetElapsedTimef() * 20.0f)); // 激しい明滅

    for (auto& b : auraBeams) {
        // 常に上昇し続けるアニメーション
        float yOffset = fmod(ofGetElapsedTimef() * b.speed * 100.0f, 2000.0f);

        ofPushMatrix();
        ofTranslate(b.x, -yOffset + 1000, b.z); // 下から上へ移動

        // 中心（明るい）
        ofSetColor(255, 255, 255, 200 * progress * flicker);
        ofDrawRectangle(-b.width * 0.1, 0, b.width * 0.2, b.height);

        // 外側（タイプカラー）
        ofSetColor(auraCol, 150 * progress * flicker);
        ofDrawRectangle(-b.width * 0.5, 0, b.width, b.height);

        ofPopMatrix();
    }

    ofDisableBlendMode();
    ofPopStyle();
}

void ofApp::executeCommand(CommandType type) {
    // クールタイム中、またはゲーム終了後は実行不可
    if (state.actionCooldown > 0 || state.bGameEnded || state.bViewMode) return;

    auto& g = config["game"];

    switch (type) {
    case CMD_WATER:
        myTree.water(1.0, state.resilienceLevel, g.value("water_increment", 15.0f));
        spawn2DEffect(P_WATER);
        break;
    case CMD_FERTILIZER:
        myTree.fertilize(1.0, state.resilienceLevel, g.value("fertilize_increment", 8.0f));
        spawn2DEffect(P_FERTILIZER);
        break;
    case CMD_KOTODAMA:
        myTree.kotodama(1.0);
        spawn2DEffect(P_KOTODAMA);
        break;
    }

    // 共通の後処理
    if (!state.bTimeFrozen) {
        myTree.incrementDay();
        checkEvolution();
        if (myTree.getDayCount() % config["game"].value("skill_interval", 5) == 0) {
            state.skillPoints++;
        }
        weather.randomize();
    }
    weather.randomize();

    // クールタイムの開始
    state.actionCooldown = state.ui.cooldownDuration;
}


//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == 'd' || key == 'D') state.bShowDebug = !state.bShowDebug;
    if (key == 'v' || key == 'V') {
        state.bViewMode = !state.bViewMode;
        state.bViewMode ? cam.enableMouseInput() : cam.disableMouseInput();
    }
    if (key == 'r' || key == 'R') {
        myTree.reset();
        particles.clear();
        particles2D.clear();
        state.skillPoints = 3;
        growthLevel = 0;
        chaosResistLevel = 0;
        bloomCatalystLevel = 0;
        state.bGameEnded = false;
    }
    if (state.bShowDebug) {
        if (key == 'w' || key == 'W') weather.randomize();
        // [T]キーで日数を一気に進める
        if (key == 't' || key == 'T') {
            for (int i = 0; i < 5; i++) {
                myTree.incrementDay();
                checkEvolution();
            }
        }
        /// [E] 成長タイプのサイクル
        if (key == 'e' || key == 'E') {
            state.currentType = static_cast<GrowthType>((state.currentType + 1) % 4);
            myTree.applyEvolution(state.currentType);
            state.evo.hasEvolvedType = true;
            state.evo.type = state.currentType;
        }
        // [F] 花の形状のサイクル修正
        if (key == 'f' || key == 'F') {
            state.currentFlowerType = static_cast<FlowerType>((state.currentFlowerType + 1) % 4);
            state.evo.hasEvolvedFlower = (state.currentFlowerType != FLOWER_NONE);
            myTree.setNeedsUpdate(); // メッシュ再構築を強制
        }
        // [P] スキル無限トグル
        if (key == 'p' || key == 'P') state.bInfiniteSkills = !state.bInfiniteSkills;
        // [Space] 時間停止トグル
        if (key == ' ') state.bTimeFrozen = !state.bTimeFrozen;
        // [+] 経験値加算（レベルアップ演出のテスト用）
        if (key == '+' || key == '=') myTree.addDebugExp(50.0f);
    }
    processCommand(key);
}

void ofApp::processCommand(int key) {
    if (state.bViewMode || myTree.getDayCount() >= state.maxDays) return;

    bool actionTaken = false;
    auto& g = config["game"];

    // 開花判定用しきい値
    float threshold = 0.4f - (bloomCatalystLevel * 0.05f);
    bool wasBloomed = (myTree.getMaxMutation() > threshold);

    if (key == '1') executeCommand(CMD_WATER);
    if (key == '2') executeCommand(CMD_FERTILIZER);
    if (key == '3') executeCommand(CMD_KOTODAMA);

    if (actionTaken) {
        myTree.incrementDay();
        checkEvolution();
        if (myTree.getDayCount() % config["game"].value("skill_interval", 5) == 0) {
            state.skillPoints++;
        }
        weather.randomize();
    }
}

//--------------------------------------------------------------

// --- スキル処理 ---
void ofApp::upgradeGrowth() { 
    if (state.skillPoints > 0 && growthLevel < 5) { 
        growthLevel++; state.skillPoints--; 
        state.auraTimer = config["ui"]["aura"].value("duration", 1.5f); // オーラタイマー始動
        spawn2DEffect(P_BLOOM);
    } 
}
void ofApp::upgradeResist() { 
    if (state.skillPoints > 0 && chaosResistLevel < 5) { 
        chaosResistLevel++; state.skillPoints--; 
        state.auraTimer = config["ui"]["aura"].value("duration", 1.5f); // オーラタイマー始動
        spawn2DEffect(P_BLOOM);
    } 
}
void ofApp::upgradeCatalyst() { 
    if (state.skillPoints > 0 && bloomCatalystLevel < 5) { 
        bloomCatalystLevel++; state.skillPoints--; 
        state.auraTimer = config["ui"]["aura"].value("duration", 1.5f); // オーラタイマー始動
        spawn2DEffect(P_BLOOM);
    } 
}

void ofApp::checkEvolution() {
    int day = myTree.getDayCount();
    // 20日目かつ、まだデフォルト状態の場合のみ実行
    if (day == 20 && state.currentType == TYPE_DEFAULT) {
        float L = myTree.getTotalLenEarned();
        float T = myTree.getTotalThickEarned();
        float M = myTree.getTotalMutationEarned();

        // 最大の蓄積値を持つパラメタに応じて分岐
        if (L >= T && L >= M) state.currentType = TYPE_ELEGANT;
        else if (T >= L && T >= M) state.currentType = TYPE_STURDY;
        else state.currentType = TYPE_ELDRITCH;

        // 木に進化を適用
        myTree.applyEvolution(state.currentType);
        state.evo.hasEvolvedType = true; // フラグを立てる (修正点)
        state.evo.type = state.currentType;

        // 進化演出：パーティクル放出
        spawn2DEffect(P_BLOOM);

        ofLogNotice("Evolution") << "Tree evolved into Type: " << state.currentType;
    }
    if (day == 40 && state.currentFlowerType == FLOWER_NONE) {
        // 現在の成長タイプに応じて花の形を決定
        if (state.currentType == TYPE_ELEGANT) state.currentFlowerType = FLOWER_CRYSTAL;
        else if (state.currentType == TYPE_STURDY) state.currentFlowerType = FLOWER_PETAL;
        else state.currentFlowerType = FLOWER_SPIRIT;

        state.evo.hasEvolvedFlower = true;
        spawn2DEffect(P_BLOOM);
        ofLogNotice("Evolution") << "Flower Evolved: " << state.currentFlowerType;
    }
}

void ofApp::keyReleased(int key) {}
void ofApp::mouseMoved(int x, int y) {}
void ofApp::mouseDragged(int x, int y, int button) {}

void ofApp::mousePressed(int x, int y, int button) {
    if (hoveredButtonIndex != -1) {
        CommandType types[] = { CMD_WATER, CMD_FERTILIZER, CMD_KOTODAMA };
        executeCommand(types[hoveredButtonIndex]);
    }
    if (hoveredSkillIndex != -1) {
        if (hoveredSkillIndex == 0) upgradeGrowth();
        else if (hoveredSkillIndex == 1) upgradeResist();
        else if (hoveredSkillIndex == 2) upgradeCatalyst();
    }
}

void ofApp::mouseReleased(int x, int y, int button) {}
void ofApp::mouseEntered(int x, int y) {}
void ofApp::mouseExited(int x, int y) {}
void ofApp::windowResized(int w, int h) {}
void ofApp::gotMessage(ofMessage msg) {}
void ofApp::dragEvent(ofDragInfo dragInfo) {}
</file>

</files>
