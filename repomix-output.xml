This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
3DFractalTree.vcxproj.filters
addons.make
bin/data/.gitkeep
bin/data/settings.json
bin/data/settings.xml
config.make
Constants.h
Ground.h
icon.rc
ofApp.cpp
Particle.h
README.md
src/main.cpp
src/ofApp.cpp
src/ofApp.h
Tree.cpp
Tree.h
Weather.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Constants.h">
// Constants.h
#pragma once
#include "ofMain.h"

struct TreeSettings {
    int maxDepth;
    float expBase, expPower;
    float lenScale, thickScale;
    float branchLenRatio, branchThickRatio;
    float baseAngle, mutationAngleMax;
    float trunkHueStart, trunkHueEnd;
    ofColor leafColor, flowerColor;
};

struct GameState {
    int dayCount = 1;
    int skillPoints = 3;
    bool bGameEnded = false;
    bool bViewMode = false;
    bool bShowDebug = false;
    string finalTitle = "";
    int maxDays = 50;
};
</file>

<file path="addons.make">
ofxGui
</file>

<file path="bin/data/.gitkeep">

</file>

<file path="bin/data/settings.xml">
<?xml version="1.0"?>
</file>

<file path="config.make">

</file>

<file path="icon.rc">
// Icon Resource Definition
#define MAIN_ICON                       102

#if defined(_DEBUG)
MAIN_ICON               ICON                    "icon_debug.ico"
#else
MAIN_ICON               ICON                    "icon.ico"
#endif
</file>

<file path="ofApp.cpp">

</file>

<file path="README.md">
# **3Dフラクタル成長シミュレーター 開発計画書 Ver.8.5**

## **1\. プロジェクト概要**

C++およびopenFrameworksを用いた、フラクタル構造の動的生成および成長シミュレーター。外部設定ファイル（JSON）によるパラメータ管理、VBOを用いた描画最適化、累進的経験値システムを特徴とする。

## **操作方法**

| button | 操作 |
| ------ | --- |
|1, 2, 3 | 育成コマンド実行 |
| W | 天候（Weather）切替（デバッグ用） |
| V | View Mode (カメラ自由操作) 切替 |
| D | 詳細デバッグ情報の表示切替 |
| R | シミュレーターの全初期化 |

## **2\. システム構成 (Architecture)**

* **開発環境**: Visual Studio 2022 / openFrameworks v0.12.1

* **外部依存**: ofxGui (標準アドオン)、verdana.ttf (フォントファイル)

* **データ管理**: `settings.json`による定数の外部保持（読み込み失敗時のフォールバック機能付き）。

* **主要クラス**:
  * **ofApp**: メインループ、入力管理、カメラ制御（自動追従/手動切替）、照明制御を担当、パーティクル寿命管理。 
  * **Tree**: フラクタル再帰計算（VBO構築）s、メッシュ生成、成長ロジック（Exp/Lv制）、パラメータ補間（Lerp）を担当。
  * **Weather**: 天候状態（SUNNY, RAINY, MOONLIGHT）の管理、背景色・バフ計算、2Dエフェクトを担当。
  * **Ground**: 平原の描画。
  * **Particle / Particle2D**: インスタンス化されたパーティクルの移動・描画ロジック。

## **3\. 技術仕様・主要機能**

### **3.1 成長システム**

* **経験値・レベル（深さ）管理**:
  * 木の「長さ（bLen）」と「太さ（bThick）」を独立した経験値として管理。
  * 枝の再帰深度（Depth）は、太さ（bThick）が指定の累積しきい値を超えた際に増加する。
  * しきい値計算式: $base \times depth^{power}$ （指数関数的な累進性）。

* **シームレス・アニメーション**:
  * 各パラメータは`lerp`により毎フレーム目標値へ補間される。
  * パラメータが一定以上の変化量を持つ期間のみ、`ofVboMesh`のクリアおよび再構築を実行し、CPU負荷を抑制。

* **コマンドと増分・トレードオフ**:
  * **Water**: `depthExp`+, `長さ`++, `太さ`-, `変異度`--
  * **Fertilizer**: `depthExp`+, `長さ`-, `太さ`++, `変異度`-
  * **Kotodama**: `depthExp`++, `長さ`+, `太さ`-, `変異度`++

* **描画・最適化**
  * **VBO集約**: 枝（五角柱）、花（球体）、葉（菱形メッシュ）の全頂点データを一つの`ofVboMesh`に格納し、ドローコールを1回に抑制。
  * **LOD (Level of Detail)**: 再帰深度に応じて幹のセグメント数（3〜5）を調整。
  * **法線計算**: 頂点ごとに法線（Normal）を設定。`ofLight`による平行光源（SUNNY）および点光源（MOONLIGHT）の陰影計算に対応。
  * **形状歪み**: `bMutation` > 0.9 の際、`ofSignedNoise`を用いて枝の頂点座標を時間経過に従い変位させる。
  * **パーティクル管理**: `std::vector` と `ofRemove` を使用した、メモリ安全な要素削除ロジック。
  * **カメラ制御**:
    * 木の推定全高に基づき、注視点（Target）と距離（Distance）を自動計算し補間移動。
    * `settings.json`より回転速度、追従感度の調整が可能。

### **3.3 UI・デバッグ**
* **トータル・スケーリング**: 基準解像度 (1024x768) に対する比率を`ofScale`で適用。
* **フォントシステム**: `ofTrueTypeFont` を採用。行列変換の影響を受けるため、ウィンドウサイズに応じて文字サイズが比例変化する。
* **デバッグモード**:
  * 'D'キーにより切り替え。FPS、累積経験値、変異度の生データを画面端に表示。

## **4\. 外部設定ファイル (settings.json) 仕様**
* **tree**: 最大深度、経験値ベース値/指数、描画スケール、分岐角、各種色彩（RGB/HSB）。
* **camera**: 回転速度、補間速度、最小距離、高さ係数。
* **weather**: 各天候の背景色。
* **game**: 最大日数、スキルポイント付与間隔、コマンドごとの基礎増分値。

## **5\. 次のステップ (Roadmap)**
* **演出強化**: 成長完了時（50日目）のカメラシーケンスの実装。
* **サウンド**: 成長段階や変異度に応じた動的な音響生成。
* **UI改善**: スキルツリーの視覚化およびインタラクションの強化。
</file>

<file path="src/main.cpp">
#include "ofMain.h"
#include "ofApp.h"

//========================================================================
int main( ){

	//Use ofGLFWWindowSettings for more options like multi-monitor fullscreen
	ofGLWindowSettings settings;
	settings.setSize(1024, 768);
	settings.windowMode = OF_WINDOW; //can also be OF_FULLSCREEN

	auto window = ofCreateWindow(settings);

	ofRunApp(window, std::make_shared<ofApp>());
	ofRunMainLoop();

}
</file>

<file path=".gitignore">
/bin/*
!/bin/data/
/obj/
/.vs/
*.sln
*.vcxproj
*.user
Verdana.ttf
</file>

<file path="bin/data/settings.json">
{
    "tree": {
        "max_depth": 6,
        "depth_exp_base": 8.0,
        "depth_exp_power": 1.6,
        "length_visual_scale": 1.5,
        "thickness_visual_scale": 0.8,
        "branch_length_ratio": 0.75,
        "branch_thick_ratio": 0.7,
        "base_angle": 25.0,
        "mutation_angle_max": 45.0,
        "colors": {
            "trunk_hue_start": 20,
            "trunk_hue_end": 160,
            "leaf": [60, 150, 60, 200],
            "flower": [255, 180, 200]
        }
    },
    "camera": {
        "rotation_speed": 0.2,
        "lerp_speed": 0.05,
        "min_distance": 600.0,
        "height_factor": 3.5
    },
    "weather": {
        "sunny_bg": [210, 230, 250],
        "rainy_bg": [100, 110, 125],
        "moonlight_bg": [20, 25, 45]
    },
    "game": {
        "max_days": 50,
        "skill_interval": 5,
        "water_increment": 15.0,
        "fertilize_increment": 8.0
    }
}
</file>

<file path="Particle.h">
#pragma once
#include "ofMain.h"

class Particle {
public:
    glm::vec3 pos, vel;
    ofColor color;
    float life = 1.0f;
    float decay;

    void setup(glm::vec3 p, glm::vec3 v, ofColor c) {
        pos = p;
        vel = v;
        color = c;
        life = 1.0f;
        decay = ofRandom(0.01f, 0.03f); // 約1〜3秒で消滅
    }

    void update() {
        pos += vel;
        life -= decay;
    }

    void draw() {
        // 寿命に応じて透明度とサイズを下げる
        ofSetColor(color, life * 255);
        ofDrawSphere(pos, 2.0f * life);
    }
};
</file>

<file path="3DFractalTree.vcxproj.filters">
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="src\ofApp.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="src\main.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxBaseGui.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxButton.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxColorPicker.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiGroup.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxInputField.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxLabel.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxPanel.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSlider.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSliderGroup.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxToggle.cpp">
      <Filter>addons\ofxGui\src</Filter>
    </ClCompile>
    <ClCompile Include="ofApp.cpp">
      <Filter>src</Filter>
    </ClCompile>
    <ClCompile Include="Tree.cpp">
      <Filter>src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="src">
      <UniqueIdentifier>{d8376475-7454-4a24-b08a-aac121d3ad6f}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons">
      <UniqueIdentifier>{2015A56A--6D1-1-44-79-A-EA4-9AEC96E18790}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons\ofxGui">
      <UniqueIdentifier>{C47F3DDD--9CE-7-4E-E5-8-762-A52490822872}</UniqueIdentifier>
    </Filter>
    <Filter Include="addons\ofxGui\src">
      <UniqueIdentifier>{B62C1517--746-D-48-72-9-B81-6F33044A72E6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\ofApp.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxBaseGui.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxButton.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxColorPicker.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGui.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiGroup.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxGuiUtils.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxInputField.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxLabel.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxPanel.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSlider.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxSliderGroup.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\of_v0.12.1_vs_64_release\addons\ofxGui\src\ofxToggle.h">
      <Filter>addons\ofxGui\src</Filter>
    </ClInclude>
    <ClInclude Include="Ground.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Particle.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Tree.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Weather.h">
      <Filter>src</Filter>
    </ClInclude>
    <ClInclude Include="Constants.h">
      <Filter>src</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="icon.rc" />
  </ItemGroup>
</Project>
</file>

<file path="Weather.h">
#pragma once
#include "ofMain.h"

enum WeatherState { SUNNY, RAINY, MOONLIGHT };

class Weather {
    // 2Dの雨線を管理する構造体
    struct RainLine {
        float x, y, speed, length;
    };
    vector<RainLine> rainLines;

public:
    WeatherState state = SUNNY;

    void setup() {
        rainLines.clear();
        // 画面全体に雨の線を初期配置
        for (int i = 0; i < 200; i++) {
            rainLines.push_back({ ofRandomWidth(), ofRandomHeight(), ofRandom(12, 25), ofRandom(15, 40) });
        }
    }

    void update() {
        if (state == RAINY) {
            for (auto& r : rainLines) {
                r.y += r.speed;
                if (r.y > ofGetHeight()) {
                    r.y = -r.length;
                    r.x = ofRandomWidth();
                }
            }
        }
    }

    // カメラの外（2D）で描画するメソッド
    void draw2D() {
        if (state == RAINY) {
            ofPushStyle();
            ofSetLineWidth(1);
            ofSetColor(170, 200, 255, 130); // 青白く少し透明な色
            for (auto& r : rainLines) {
                ofDrawLine(r.x, r.y, r.x, r.y + r.length);
            }
            ofPopStyle();
        }
    }

    void toggle() { state = static_cast<WeatherState>((state + 1) % 3); }
    void randomize() { state = static_cast<WeatherState>((int)ofRandom(0, 3)); }
    string getName() {
        if (state == SUNNY) return "SUNNY";
        if (state == RAINY) return "RAINY";
        return "MOONLIGHT";
    }
    // ofApp から渡された config を使って背景色を決定
    ofColor getBgFromConfig(const ofJson& config) {
        string key = "";
        if (state == SUNNY) key = "sunny_bg";
        else if (state == RAINY) key = "rainy_bg";
        else key = "moonlight_bg";

        auto c = config["weather"][key];
        return ofColor(c[0], c[1], c[2]);
    }

    float getGrowthBuff() { return 1.5f; }
};
</file>

<file path="src/ofApp.cpp">
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetFrameRate(60);
    ofEnableDepthTest();
    ofEnableSmoothing();

    config = ofLoadJson("settings.json");
    if (config.empty()) {
        ofLogError("ofApp") << "settings.json not found! Using hardcoded defaults.";
        config["game"]["water_increment"] = 15.0;
        config["game"]["fertilize_increment"] = 8.0;
        config["camera"]["height_factor"] = 3.5;
    }
    mainFont.load("verdana.ttf", 10, true, true);

    // state構造体の初期化
    state.skillPoints = 3;
    state.maxDays = config["game"].value("max_days", 50);
    state.bGameEnded = false;
    state.bViewMode = false;
    state.bShowDebug = false;

    myTree.setup(config);
    weather.setup();
    ground.setup();

    // --- GUI初期化 ---
    gui.setup("Skill & Debug", "settings.xml", 20, 150);
    gui.add(growthLevel.set("Growth Efficiency", 0, 0, 5));
    gui.add(chaosResistLevel.set("Chaos Resistance", 0, 0, 5));
    gui.add(bloomCatalystLevel.set("Bloom Catalyst", 0, 0, 5));

    gui.add(btnGrowth.setup("Upgrade Growth (1pt)"));
    gui.add(btnResist.setup("Upgrade Resistance (1pt)"));
    gui.add(btnCatalyst.setup("Upgrade Bloom (1pt)"));

    btnGrowth.addListener(this, &ofApp::upgradeGrowth);
    btnResist.addListener(this, &ofApp::upgradeResist);
    btnCatalyst.addListener(this, &ofApp::upgradeCatalyst);

    ofEnableLighting();
    light.setup();
    cam.setDistance(400);
    cam.setGlobalPosition(ofVec3f(0, 150, 150));
    cam.lookAt(ofVec3f(0, 0, 0));
    cam.setNearClip(0.1);
    cam.setFarClip(20000);
    cam.setTarget(ofVec3f(0, 0, 0));
    cam.disableMouseInput();
}

//--------------------------------------------------------------
void ofApp::update() {
    // 終了判定
    if (myTree.getDayCount() >= state.maxDays && !state.bGameEnded) {
        state.bGameEnded = true;
        // 称号決定
        if (myTree.getLen() > 200 && myTree.getMaxMutation() < 0.3) state.finalTitle = "Elegant Giant";
        else if (myTree.getMaxMutation() > 0.8) state.finalTitle = "Herald of Chaos";
        else state.finalTitle = "Great Spirit Tree";
    }

    myTree.update(growthLevel, chaosResistLevel, bloomCatalystLevel);
    weather.update();

    updateCamera();

    visualDepthProgress = ofLerp(visualDepthProgress, myTree.getDepthProgress(), 0.1f);

    // パーティクル更新
    for (auto& p : particles) p.update();
    ofRemove(particles, [](Particle& p) { return p.life <= 0; });
    for (auto& p : particles2D) p.update();
    ofRemove(particles2D, [](Particle2D& p) { return p.life <= 0; });
    if (weather.state == RAINY && ofGetFrameNum() % 3 == 0) {
        spawn2DEffect(P_RAIN_SPLASH);
    }

    //if (bGameEnded && !bViewMode) {
    //    // 【修正】終了時のカメラ：水平視点かつ木のサイズに合わせた距離
    //    camAutoRotation += 0.3f;
    //    float centerHeight = myTree.getLen() * 1.5f; // 木の中心
    //    float targetDist = myTree.getLen() * 5.0f;   // 木のサイズに合わせた距離

    //    float rad = ofDegToRad(camAutoRotation);
    //    // y座標を centerHeight と同じにすることで水平を保つ
    //    cam.setPosition(sin(rad) * targetDist, centerHeight, cos(rad) * targetDist);
    //    cam.lookAt(glm::vec3(0, centerHeight, 0));
    //}
    //else if (!bViewMode) {
    //    // --- カメラの自動ズームと回転 ---
    //    float currentTreeHeight = myTree.getLen() * 3.5f;
    //    float targetDistance = max(600.0f, currentTreeHeight * 1.5f);
    //    float lerpedDistance = ofLerp(cam.getDistance(), targetDistance, 0.05f);
    //    cam.setDistance(lerpedDistance);

    //    // 中心（高さの40%付近）を見つめる
    //    ofVec3f newTarget(0, currentTreeHeight * 0.4f, 0);

    //    ofVec3f currentTarget = cam.getTarget().getPosition();
    //    ofVec3f lerpedTarget = currentTarget.getInterpolated(newTarget, 0.05f);
    //    cam.setTarget(lerpedTarget);

    //    // 毎フレーム少しずつ回転角を増やす
    //    camAutoRotation += 0.2f;
    //    // カメラの位置を円周上で計算して更新
    //    float rad = ofDegToRad(camAutoRotation);
    //    cam.setPosition(sin(rad) * lerpedDistance, newTarget.y, cos(rad) * lerpedDistance);
    //    cam.lookAt(newTarget);
    //}
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofBackground(weather.getBgFromConfig(config));

    ofEnableDepthTest();
    ofEnableLighting();
    setupLighting();

    cam.begin();
    ground.draw();
    myTree.draw();
    for (auto& p : particles) p.draw();
    cam.end();

    light.disable();
    ofDisableLighting();
    ofDisableDepthTest();

    for (auto& p : particles2D) p.draw();
    weather.draw2D();

    if (state.bViewMode) drawViewModeOverlay();
    else drawHUD();

    if (state.bShowDebug) drawDebugOverlay();
}
void ofApp::updateCamera() {
    if (state.bViewMode) return;

    float hFactor = config["camera"].value("height_factor", 3.5f);
    float treeH = myTree.getLen() * hFactor;
    float targetDist, lookAtY;

    if (state.bGameEnded) {
        camAutoRotation += 0.4f;
        targetDist = myTree.getLen() * 5.0f;
        lookAtY = treeH * 0.4f;

        float rad = ofDegToRad(camAutoRotation);
        cam.setPosition(sin(rad) * targetDist, lookAtY + 50, cos(rad) * targetDist);
        cam.lookAt(glm::vec3(0, lookAtY, 0));
    }
    else {
        camAutoRotation += 0.2f;
        targetDist = max(600.0f, treeH * 1.5f);
        lookAtY = treeH * 0.4f;

        float rad = ofDegToRad(camAutoRotation);
        glm::vec3 targetPos(sin(rad) * targetDist, lookAtY + 100, cos(rad) * targetDist);

        cam.setTarget(glm::vec3(0, lookAtY, 0));
        cam.setPosition(targetPos);
        cam.lookAt(glm::vec3(0, lookAtY, 0));
    }

/*    float rad = ofDegToRad(camAutoRotation);
    glm::vec3 targetPos(sin(rad) * targetDist, lookAtY + 100, cos(rad) * targetDist);

    cam.setTarget(glm::vec3(0, lookAtY, 0));
    cam.setPosition(targetPos);
    cam.lookAt(glm::vec3(0, lookAtY, 0))*/;
}

void ofApp::spawnBloomParticles() {
    for (int i = 0; i < 30; i++) {
        Particle p;
        p.setup(glm::vec3(0, myTree.getLen() * 2, 0),
            glm::vec3(ofRandom(-2, 2), ofRandom(2, 5), ofRandom(-2, 2)),
            ofColor(255, 150, 200));
        particles.push_back(p);
    }
}

//--------------------------------------------------------------
void ofApp::setupLighting() {
    // 天候ごとのライティング・プリセット
    switch (weather.state) {
    case SUNNY:
        light.setDirectional();
        light.setDiffuseColor(ofColor(255, 250, 230));
        light.setOrientation(glm::vec3(-45, -45, 0));
        break;
    case MOONLIGHT:
        light.setPointLight();
        light.setDiffuseColor(ofColor(120, 150, 255));
        light.setPosition(0, 500, 200);
        break;
    case RAINY:
        light.setPointLight();
        light.setDiffuseColor(ofColor(50, 60, 80));
        light.setPosition(0, 800, 0);
        break;
    }
    light.enable();
}

//--------------------------------------------------------------
float ofApp::getUIScale() {
    float baseW = 1024.0f; // 開発時の基準幅
    float baseH = 768.0f;  // 開発時の基準高さ
    // 縦横の比率のうち、小さい方に合わせることで画面外へのはみ出しを防ぐ
    return glm::min(ofGetWidth() / baseW, ofGetHeight() / baseH);
}

void ofApp::drawHUD() {
    float scale = getUIScale();
    ofPushMatrix();
    ofScale(scale, scale);

    ofSetColor(0, 180);
    ofDrawRectangle(15, 15, 300, 35);
    ofSetColor(255);
    mainFont.drawString("DAY: " + ofToString(myTree.getDayCount()) + " / " + ofToString(state.maxDays), 25, 40);

    drawControlPanel();
    drawStatusPanel();

    if (state.bGameEnded) {
        ofSetColor(255, 215, 0);
        string msg = "EVOLUTION COMPLETE: " + state.finalTitle;
        mainFont.drawString(msg, 512 - mainFont.stringWidth(msg) / 2, 384);
    }
    ofPopMatrix();
}

// ステータスパネル（プログレスバー）の描画
void ofApp::drawStatusPanel() {
    float scale = getUIScale();
    ofPushMatrix();
    // 右下を起点に配置
    float pW = 320, pH = 180;
    float margin = 20 * scale;;
    // 画面比率に合わせて右下を起点に配置
    ofTranslate(ofGetWidth() - (pW * scale) - margin, ofGetHeight() - (pH * scale) - margin);
    ofScale(scale, scale);
    // 背景
    ofSetColor(0, 160);
    ofDrawRectRounded(0, 0, pW, pH, 10);
    // 1. 深さ（レベル表示 + スムーズな経験値）
    string lvStr = "Depth Level " + ofToString(myTree.getDepthLevel());
    drawDualParamBar(lvStr, 25, 45, 270, visualDepthProgress, 0, ofColor(120, 255, 100));
    // 2. 木の長さ
    drawDualParamBar("Total Length", 25, 95, 270, ofClamp(myTree.getLen() / 400.0f, 0, 1), 0, ofColor(100, 200, 255));
    // 3. カオス度（現在と最大を一つのバーに統合）
    // 背景(Memory)に最大値、前面(Current)に現在値を描画
    drawDualParamBar("Chaos (Cur / Max)", 25, 145, 270, myTree.getCurMutation(), myTree.getMaxMutation(), ofColor(255, 80, 150));
    ofPopMatrix();
}

void ofApp::drawDualParamBar(string label, float x, float y, float w, float currentRatio, float maxRatio, ofColor col) {
    ofPushStyle();
    // 動的ラベル背景（文字の長さにフィット）
    float tw = mainFont.stringWidth(label) + 12;
    ofSetColor(0, 220);
    ofDrawRectangle(x - 2, y - 22, tw, 18);
    ofSetColor(255);
    mainFont.drawString(label, x + 3, y - 8);
    // バー背景
    ofSetColor(40);
    ofDrawRectangle(x, y, w, 14);
    // 最大値（記憶）の薄い表示
    if (maxRatio > 0) {
        ofSetColor(col, 60);
        ofDrawRectangle(x, y, w * maxRatio, 14);
    }
    // 現在値
    ofSetColor(col, 255);
    ofDrawRectangle(x, y, w * currentRatio, 14);
    ofPopStyle();
}

// コントロールパネルの描画
void ofApp::drawControlPanel() {
    float scale = glm::min(ofGetWidth() / 1024.0f, ofGetHeight() / 768.0f);
    ofPushStyle();
    ofPushMatrix();

    float panelW = 240; // 少し幅を広げる
    float panelH = 380; // 情報量に合わせて高くする
    ofTranslate(20 * scale, 120 * scale);
    ofScale(scale, scale);

    // 背景
    ofSetColor(0, 0, 0, 180);
    ofDrawRectRounded(0, 0, panelW, panelH, 8);

    // --- 詳細ステータス表示 ---
    ofSetColor(255);
    int ty = 25;
    mainFont.drawString("=== TREE STATUS ===", 15, ty); ty += 25;
    ofSetColor(200, 255, 200);
    mainFont.drawString("Growth Lvl:  " + ofToString(growthLevel), 15, ty); ty += 18;
    ofSetColor(200, 200, 255);
    mainFont.drawString("Resist Lvl:  " + ofToString(chaosResistLevel), 15, ty); ty += 18;
    ofSetColor(255, 200, 200);
    mainFont.drawString("Catalyst:    " + ofToString(bloomCatalystLevel), 15, ty); ty += 25;

    // 天候ボーナス表示
    ofSetColor(255, 255, 0);
    string buffInfo = "Weather Buff: ";
    if (weather.state == SUNNY) buffInfo += "Water+";
    else if (weather.state == RAINY) buffInfo += "Fertilizer+";
    else if (weather.state == MOONLIGHT) buffInfo += "Kotodama+";
    mainFont.drawString(buffInfo, 15, ty); ty += 25;

    // 残り日数
    int maxDays = config["game"].value("max_days", 50);
    int daysLeft = maxDays - myTree.getDayCount();
    ofSetColor(255);
    mainFont.drawString("Days to Limit: " + ofToString(daysLeft), 15, ty); ty += 30;

    // ofxGuiの位置調整
    gui.setPosition(30, ty);
    gui.draw();

    // コマンドガイド
    ofSetColor(200);
    string cmds = "[1] Water  [2] Fertilizer\n[3] Kotodama\n\n'V' ViewMode  'D' Debug\n'R' Reset";
    mainFont.drawString(cmds, 15, panelH - 90);

    ofPopMatrix();
    ofPopStyle();
}

void ofApp::drawDebugOverlay() {
    float scale = getUIScale();
    ofPushStyle();
    ofScale(scale, scale);
    string d = "=== DEBUG INFO ===\n";
    d += "FPS: " + ofToString(ofGetFrameRate(), 1) + "\n";
    d += "VBO Vertices: " + ofToString(myTree.getVboMesh().getNumVertices()) + "\n";
    d += "2D Particles: " + ofToString(particles2D.size()) + "\n";
    d += "3D Particles: " + ofToString(particles.size()) + "\n";
    d += "------------------\n";
    d += "Depth: " + ofToString(myTree.getDepthLevel()) + " / " + ofToString(config["tree"].value("max_depth", 8)) + "\n";
    d += "Exp: " + ofToString(myTree.getDepthExp(), 1) + "\n";
    d += "Length: " + ofToString(myTree.getLen(), 1) + " (Target: " + ofToString(myTree.getLen(), 1) + ")\n";
    d += "Thick: " + ofToString(myTree.getThick(), 1) + "\n";
    d += "Mutation: " + ofToString(myTree.getMaxMutation(), 3);
    float dw = 300;
    ofSetColor(0, 200);
    ofDrawRectangle(ofGetWidth() / scale - dw - 20, 20, dw, 190);
    ofSetColor(0, 255, 0);
    mainFont.drawString(d, ofGetWidth() / scale - dw - 10, 40);

    ofPopMatrix();
    ofPopStyle();
}

// View Modeのオーバーレイ
void ofApp::drawViewModeOverlay() {
    ofPushStyle();
    string msg = "VIEW MODE : Orbit(Mouse) / Return('V')";
    float w = msg.length() * 8 + 20;
    ofSetColor(0, 0, 0, 200);
    ofDrawRectangle(ofGetWidth() / 2 - w / 2, ofGetHeight() - 50, w, 30);
    ofSetColor(255);
    ofDrawBitmapString(msg, ofGetWidth() / 2 - w / 2 + 10, ofGetHeight() - 30);
    ofPopStyle();
}

// 演出生成の実装
void ofApp::spawn2DEffect(ParticleType type) {
    int count = (type == P_RAIN_SPLASH) ? 1 : 60;

    for (int i = 0; i < count; i++) {
        Particle2D p;
        p.type = type;

        switch (type) {
        case P_WATER: {
            p.pos = { (float)ofRandomWidth(), -20.0f };
            p.vel = { ofRandom(-3, 3), ofRandom(10, 20) };
            p.color = ofColor(120, 200, 255);
            p.size = ofRandom(3, 8);
            p.decay = ofRandom(0.01, 0.03);
        }break;

        case P_FERTILIZER: {
            p.pos = { (float)ofRandomWidth(), (float)ofGetHeight() + 20.0f };
            p.vel = { ofRandom(-4, 4), ofRandom(-8.0f, -4.0f) };
            p.color = ofColor(180, 255, 100);
            p.size = ofRandom(8, 15);
            p.decay = ofRandom(0.005, 0.015);
        }break;

        case P_KOTODAMA: {
            p.pos = { (float)ofGetWidth() / 2, (float)ofGetHeight() / 2 };
            float angle = ofRandom(TWO_PI);
            float spd = ofRandom(5, 15);
            p.vel = { cos(angle) * spd, sin(angle) * spd };
            p.color = ofColor(200, 160, 255);
            p.size = ofRandom(10, 30);
            p.decay = ofRandom(0.02, 0.04);
        }break;

        case P_RAIN_SPLASH: {
            p.pos = { ofRandomWidth(), ofRandom(ofGetHeight() * 0.8, ofGetHeight()) };
            p.vel = { 0, 0 };
            p.color = ofColor(150, 180, 255, 100);
            p.size = ofRandom(5, 15);
            p.decay = 0.05;
        }break;

        case P_BLOOM: {
            p.pos = { (float)ofGetWidth() / 2.0f + ofRandom(-150, 150),
                      (float)ofGetHeight() / 2.0f + ofRandom(-150, 150) };
            p.vel = { ofRandom(-2, 2), ofRandom(-2, 2) };
            p.color = ofColor(255, 200, 230);
            p.size = ofRandom(2, 4);
            p.decay = 0.02f;
        } break;
        }
        particles2D.push_back(p);
    }
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == 'd' || key == 'D') state.bShowDebug = !state.bShowDebug;
    if (key == 'w' || key == 'W') weather.randomize();
    if (key == 'v' || key == 'V') {
        state.bViewMode = !state.bViewMode;
        state.bViewMode ? cam.enableMouseInput() : cam.disableMouseInput();
    }
    if (state.bShowDebug && key == '+') {
        myTree.water(5.0, 0, 50.0);
        myTree.fertilize(5.0, 50.0);
    }
    if (key == 'r' || key == 'R') {
        myTree.reset();
        particles.clear();
        particles2D.clear();
        state.skillPoints = 3;
        growthLevel = 0;
        chaosResistLevel = 0;
        bloomCatalystLevel = 0;
        state.bGameEnded = false;
    }
    processCommand(key);
}

void ofApp::processCommand(int key) {
    if (state.bViewMode || myTree.getDayCount() >= state.maxDays) return;

    bool actionTaken = false;
    auto& g = config["game"];

    // 開花判定用しきい値
    float threshold = 0.4f - (bloomCatalystLevel * 0.05f);
    bool wasBloomed = (myTree.getMaxMutation() > threshold);

    if (key == '1') {
        myTree.water(1.0, growthLevel, g.value("water_increment", 15.0f));
        spawn2DEffect(P_WATER);
        actionTaken = true;
    }
    else if (key == '2') {
        myTree.fertilize(1.0, g.value("fertilize_increment", 8.0f));
        spawn2DEffect(P_FERTILIZER);
        actionTaken = true;
    }
    else if (key == '3') {
        myTree.kotodama(1.0);
        spawn2DEffect(P_KOTODAMA);
        actionTaken = true;
    }

    if (actionTaken) {
        myTree.incrementDay();
        if (myTree.getDayCount() % config["game"].value("skill_interval", 5) == 0) {
            state.skillPoints++;
        }
        weather.randomize();
    }
}

//--------------------------------------------------------------

// --- スキル処理 ---
void ofApp::upgradeGrowth() { if (state.skillPoints > 0 && growthLevel < 5) { growthLevel++; state.skillPoints--; } }
void ofApp::upgradeResist() { if (state.skillPoints > 0 && chaosResistLevel < 5) { chaosResistLevel++; state.skillPoints--; } }
void ofApp::upgradeCatalyst() { if (state.skillPoints > 0 && bloomCatalystLevel < 5) { bloomCatalystLevel++; state.skillPoints--; } }

void ofApp::keyReleased(int key) {}
void ofApp::mouseMoved(int x, int y) {}
void ofApp::mouseDragged(int x, int y, int button) {}
void ofApp::mousePressed(int x, int y, int button) {}
void ofApp::mouseReleased(int x, int y, int button) {}
void ofApp::mouseEntered(int x, int y) {}
void ofApp::mouseExited(int x, int y) {}
void ofApp::windowResized(int w, int h) {}
void ofApp::gotMessage(ofMessage msg) {}
void ofApp::dragEvent(ofDragInfo dragInfo) {}
</file>

<file path="src/ofApp.h">
#pragma once
#include "ofMain.h"
#include "ofxGui.h"
#include "..\Tree.h"
#include "..\Weather.h"
#include "..\Ground.h"
#include "../Particle.h"


enum ParticleType { P_WATER, P_FERTILIZER, P_KOTODAMA, P_RAIN_SPLASH, P_BLOOM };

struct Particle2D {
	glm::vec2 pos, vel;
	ofColor color;
	float size, life = 1.0, decay;
	ParticleType type;

	void update() {
		pos += vel;
		if (type == P_FERTILIZER) pos.x += sin(ofGetElapsedTimef() * 5.0) * 2.0;
		life -= decay;
	}

	void draw() {
		ofSetColor(color, life * 255);
		if (type == P_RAIN_SPLASH) {
			ofSetLineWidth(2);
			ofNoFill();
			ofDrawEllipse(pos, size * (1.0 - life) * 2.0, size * (1.0 - life)); // 広がる波紋
			ofFill();
		}
		else {
			ofDrawCircle(pos, size * (life + 0.2)); // 徐々に小さくなる円
		}
	}
};

class ofApp : public ofBaseApp{
	public:
		// --- 標準イベント ---
		void setup();
		void update();
		void draw();
		void keyPressed(int key);

		// --- 各種イベント ---
		void keyReleased(int key);
		void mouseMoved(int x, int y );
		void mouseDragged(int x, int y, int button);
		void mousePressed(int x, int y, int button);
		void mouseReleased(int x, int y, int button);
		void mouseEntered(int x, int y);
		void mouseExited(int x, int y);
		void windowResized(int w, int h);
		void dragEvent(ofDragInfo dragInfo);
		void gotMessage(ofMessage msg);

	private:
		// UIコンポーネントの分割
		void drawHUD();
		void drawStatusPanel();
		void drawControlPanel();
		void drawViewModeOverlay();
		void drawDebugOverlay();
		ofTrueTypeFont mainFont;
		float getUIScale();
		void drawDualParamBar(string label, float x, float y, float w, float currentRatio, float maxRatio, ofColor col);

		void updateCamera();
		void processCommand(int key);
		void setupLighting();
		void spawnBloomParticles();
		void spawn2DEffect(ParticleType type);

		// --- スキル処理 ---
		void upgradeGrowth();
		void upgradeResist();
		void upgradeCatalyst();

		// --- システム変数と設定 ---
		ofJson config;
		GameState state;
		float camAutoRotation = 0;
		float visualDepthProgress = 0;

		// --- オブジェクト群 ---
		Tree myTree;
		Weather weather;
		Ground ground;
		ofEasyCam cam;
		ofLight light;
		vector<Particle> particles;
		vector<Particle2D> particles2D;

		// --- GUI ---
		ofxPanel gui;
		ofParameter<int> growthLevel, chaosResistLevel, bloomCatalystLevel;
		ofxButton btnGrowth, btnResist, btnCatalyst;
};
</file>

<file path="Tree.cpp">
#include "Tree.h"
void Tree::setup(const ofJson& config) {
    seed = ofRandom(99999);
    auto t = config["tree"];
    s.maxDepth = t.value("max_depth", 6);
    s.expBase = t.value("depth_exp_base", 30.0f);
    s.expPower = t.value("depth_exp_power", 1.6f);
    s.lenScale = t.value("length_visual_scale", 1.5f);
    s.thickScale = t.value("thickness_visual_scale", 0.8f);
    s.branchLenRatio = t.value("branch_length_ratio", 0.75f);
    s.branchThickRatio = t.value("branch_thick_ratio", 0.7f);
    s.baseAngle = t.value("base_angle", 25.0f);
    s.mutationAngleMax = t.value("mutation_angle_max", 45.0f);

    auto c = t["colors"];
    s.trunkHueStart = c.value("trunk_hue_start", 20.0f);
    s.trunkHueEnd = c.value("trunk_hue_end", 160.0f);
    s.leafColor = ofColor(c["leaf"][0], c["leaf"][1], c["leaf"][2], c["leaf"][3]);
}

void Tree::update(int growthLevel, int chaosResist, int bloomLevel) {
    // 補間ロジックは維持
    bLen = ofLerp(bLen, tLen, 0.1f);
    bThick = ofLerp(bThick, tThick, 0.1f);
    bMutation = ofLerp(bMutation, tMutation, 0.1f);

    if (depthLevel < s.maxDepth && depthExp >= getExpForDepth(depthLevel + 1)) {
        depthLevel++;
        bNeedsUpdate = true;
    }

    if (bNeedsUpdate || abs(bLen - tLen) > 0.5f || abs(bThick - tThick) > 0.1f) {
        vboMesh.clear();
        ofSetRandomSeed(seed);
        // 構造体 s を経由して描画パラメータを渡す
        buildBranchMesh(bLen * s.lenScale, bThick * s.thickScale, depthLevel, glm::mat4(1.0), chaosResist, bloomLevel);
        bNeedsUpdate = false;
    }
}

void Tree::draw() {
    vboMesh.draw();
}

void Tree::water(float buff, int growthLevel, float increment) {
    depthExp += 5.0f * buff;                  // Depth +
    tLen += increment * 2.0f * buff;          // 長さ ++
    tThick = max(2.0f, tThick - 3.0f);        // 太さ - (最小値2)
    tMutation = max(0.0f, tMutation - 0.1f);  // カオス --
}

void Tree::fertilize(float buff, float increment) {
    depthExp += 5.0f * buff;                  // Depth +
    tLen = max(10.0f, tLen - 5.0f);           // 長さ - (最小値10)
    tThick += increment * 2.0f * buff;        // 太さ ++
    tMutation = max(0.0f, tMutation - 0.05f); // カオス -
}

void Tree::kotodama(float buff) {
    depthExp += 5.0f * buff;                 // Depth ++
    tLen += 10.0f * buff;                     // 長さ +
    tThick = max(2.0f, tThick - 5.0f);        // 太さ -
    tMutation = ofClamp(tMutation + 0.2f * buff, 0.0f, 1.0f); // カオス +
}

glm::mat4 Tree::getNextBranchMatrix(glm::mat4 tipMat, int index, int total, float angleBase) {
    glm::mat4 m = tipMat;
    // Y軸回転で円状に配置
    m = glm::rotate(m, glm::radians(index * (360.0f / total)), glm::vec3(0, 1, 0));
    // 外側へ倒す回転（カオス度による揺らぎ）
    float wobble = ofRandom(-10, 10) * bMutation;
    m = glm::rotate(m, glm::radians(angleBase + wobble), glm::vec3(0, 0, 1));
    return m;
}

void Tree::buildBranchMesh(float length, float thickness, int depth, glm::mat4 mat, int chaosResist, int bloomLevel) {
    if (depth < 0) return;

    // 現在の枝（幹）をメッシュに追加
    addStemToMesh(thickness, thickness * s.branchThickRatio, length, mat, chaosResist, depth);

    // 枝の先端の行列を計算
    glm::mat4 tipMat = glm::translate(mat, glm::vec3(0, length, 0));

    // --- 装飾（葉・花）のロジック ---
    float bloomThreshold = 0.4f - (bloomLevel * 0.05f);
    bool isBloomed = (maxMutationReached > bloomThreshold);

    if (isBloomed) {
        if (depth == 0) addFlowerToMesh(thickness, tipMat);
        else if (depth <= 1) addLeafToMesh(thickness, tipMat);
    }
    else if (depth <= 1) {
        addLeafToMesh(thickness, tipMat);
    }

    // --- 次の枝への再帰 ---
    int numBranches = (depth < 2) ? 2 : 3;
    float angleBase = 25.0f + (bMutation * 45.0f); // カオス度で分岐角が広がる

    for (int i = 0; i < numBranches; i++) {
        glm::mat4 childMat = getNextBranchMatrix(tipMat, i, numBranches, angleBase);
        buildBranchMesh(length * s.branchLenRatio, thickness * s.branchThickRatio, depth - 1, childMat, chaosResist, bloomLevel);
    }
}

void Tree::addStemToMesh(float r1, float r2, float h, glm::mat4 mat, int chaosResist, int depth) {
    int segments = (depth <= 4) ? 3 : 5;

    float timeShift = ofGetElapsedTimef() * 20.0f;
    float hueBase = ofMap(bMutation, 0, 1, s.trunkHueStart, s.trunkHueEnd);
    float finalHue = fmod(hueBase + timeShift + (depth * 10), 255.0f);
    ofColor col = ofColor::fromHsb(finalHue, 160, 180 + (depth * 10));
    
    float collapseThreshold = 0.9f + (chaosResist * 0.02f);
    // 法線変換用の行列
    glm::mat3 normalMatrix = glm::inverseTranspose(glm::mat3(mat));

    for (int i = 0; i < segments; i++) {
        float a1 = i * TWO_PI / segments;
        float a2 = (i + 1) * TWO_PI / segments;
        glm::vec3 n1(cos(a1), 0, sin(a1)), n2(cos(a2), 0, sin(a2));
        glm::vec4 p1(n1.x * r1, 0, n1.z * r1, 1), p2(n2.x * r1, 0, n2.z * r1, 1);
        glm::vec4 p3(n1.x * r2, h, n1.z * r2, 1), p4(n2.x * r2, h, n2.z * r2, 1);

        // 変異度に基づいた形状のノイズアニメーション
        if (maxMutationReached > 0.5f) {
            float nStr = ofMap(maxMutationReached, 0.5, 1.0, 0, 120.0f, true);
            auto applyNoise = [&](glm::vec4& p) {
                p.x += ofSignedNoise(p.x * 0.1, p.y * 0.1, ofGetElapsedTimef()) * nStr;
                p.z += ofSignedNoise(p.z * 0.1, p.y * 0.1, ofGetElapsedTimef() + 10) * nStr;
                };
            applyNoise(p3); applyNoise(p4);
        }

        // VBO登録 (三角形1, 2)
        vboMesh.addVertex(glm::vec3(mat * p1)); vboMesh.addNormal(normalMatrix * n1); vboMesh.addColor(col);
        vboMesh.addVertex(glm::vec3(mat * p2)); vboMesh.addNormal(normalMatrix * n2); vboMesh.addColor(col);
        vboMesh.addVertex(glm::vec3(mat * p3)); vboMesh.addNormal(normalMatrix * n1); vboMesh.addColor(col);
        vboMesh.addVertex(glm::vec3(mat * p2)); vboMesh.addNormal(normalMatrix * n2); vboMesh.addColor(col);
        vboMesh.addVertex(glm::vec3(mat * p4)); vboMesh.addNormal(normalMatrix * n2); vboMesh.addColor(col);
        vboMesh.addVertex(glm::vec3(mat * p3)); vboMesh.addNormal(normalMatrix * n1); vboMesh.addColor(col);
    }
}

float Tree::getExpForDepth(int d) {
    if (d <= 0) return 0;
    return s.expBase * pow((float)d, s.expPower);
}

float Tree::getDepthProgress() {
    // 現在のレベルと次のレベルに必要な経験値を取得
    float curThreshold = getExpForDepth(depthLevel);
    float nxtThreshold = getExpForDepth(depthLevel + 1);

    // 0除算を防ぐ
    if (nxtThreshold <= curThreshold) return 1.0f;

    // 現在のレベル内での進捗率を 0.0 ~ 1.0 で返す
    return ofClamp((depthExp - curThreshold) / (nxtThreshold - curThreshold), 0.0f, 1.0f);
}

void Tree::addLeafToMesh(float thickness, glm::mat4 mat) {
    ofColor lCol(60, 150, 60, 200);
    float w = thickness * 3.0f;
    float h = thickness * 6.0f;

    // 葉の4頂点（ひし形）
    glm::vec4 p1(0, 0, 0, 1);           // 付け根
    glm::vec4 p2(-w, h * 0.5f, 0, 1);   // 左
    glm::vec4 p3(w, h * 0.5f, 0, 1);    // 右
    glm::vec4 p4(0, h, 0, 1);           // 先端

    glm::vec3 n(0, 0, 1); // 法線

    // 三角形1
    vboMesh.addVertex(glm::vec3(mat * p1)); vboMesh.addNormal(n); vboMesh.addColor(lCol);
    vboMesh.addVertex(glm::vec3(mat * p2)); vboMesh.addNormal(n); vboMesh.addColor(lCol);
    vboMesh.addVertex(glm::vec3(mat * p4)); vboMesh.addNormal(n); vboMesh.addColor(lCol);
    // 三角形2
    vboMesh.addVertex(glm::vec3(mat * p1)); vboMesh.addNormal(n); vboMesh.addColor(lCol);
    vboMesh.addVertex(glm::vec3(mat * p3)); vboMesh.addNormal(n); vboMesh.addColor(lCol);
    vboMesh.addVertex(glm::vec3(mat * p4)); vboMesh.addNormal(n); vboMesh.addColor(lCol);
}

void Tree::addFlowerToMesh(float thickness, glm::mat4 mat) {
    ofColor fCol(255, 180, 200);
    float radius = thickness * 2.2f;
    int res = 6; // 分割数（高くすると重くなります）

    // 球体の頂点生成ロジック
    for (int i = 0; i <= res; i++) {
        float lat0 = PI * (-0.5f + (float)(i - 1) / res);
        float z0 = sin(lat0);
        float zr0 = cos(lat0);

        float lat1 = PI * (-0.5f + (float)i / res);
        float z1 = sin(lat1);
        float zr1 = cos(lat1);

        for (int j = 0; j <= res; j++) {
            float lng = 2 * PI * (float)(j - 1) / res;
            float x = cos(lng);
            float y = sin(lng);

            // 球体の頂点（法線は中心からのベクトル）
            glm::vec3 n(x * zr1, y * zr1, z1);
            glm::vec3 p = n * radius;

            // 枝の先端（h）の位置に配置されるよう、行列を適用
            vboMesh.addVertex(glm::vec3(mat * glm::vec4(p, 1)));
            vboMesh.addNormal(glm::normalize(glm::mat3(mat) * n));
            vboMesh.addColor(fCol);
        }
    }
}

void Tree::reset() {
    // 育成状態の初期化
    dayCount = 1;
    maxMutationReached = 0;
    depthExp = 0;
    depthLevel = 0;
    // パラメータを初期値へ
    bLen = 0; tLen = 10;
    bThick = 0; tThick = 2;
    bMutation = 0; tMutation = 0;

    // 木の形状シードを再生成
    seed = ofRandom(99999);
    vboMesh.clear();
    bNeedsUpdate = true;
}

int Tree::getCurrentDepth() {
    return depthLevel;
}
</file>

<file path="Tree.h">
#pragma once
#include "ofMain.h"
#include "Constants.h"

class Tree {
public:
    void setup(const ofJson& config);
    void update(int growthLevel, int chaosResist, int bloomLevel);
    void draw();
    void reset();

    void water(float buff, int growthLevel, float increment);      // 長さを伸ばし、カオス度を下げる
    void fertilize(float buff, float increment);  // 太さを増し、カオス度を下げる
    void kotodama(float buff);   // カオス度を上げる
    void incrementDay() { if (dayCount < 50) dayCount++; }

    // --- アクセサ・ユーティリティ ---
    float getLen() { return bLen; }
    float getThick() { return bThick; }
    float getMaxMutation() { return maxMutationReached; }
    float getCurMutation() { return bMutation; }
    float getDepthExp() { return depthExp; }
    int getDepthLevel() { return depthLevel; }
    int getCurrentDepth();
    int getDayCount() { return dayCount; }
    int getSeed() { return seed; }
    float getDepthProgress();
    ofVboMesh& getVboMesh() { return vboMesh; }

private:
    // 内部ロジック：座標変換とメッシュ構築
    glm::mat4 getNextBranchMatrix(glm::mat4 tipMat, int index, int total, float angleBase);
    void buildBranchMesh(float length, float thickness, int depth, glm::mat4 mat, int chaosResist, int bloomLevel);
    void addStemToMesh(float r1, float r2, float h, glm::mat4 mat, int chaosResist,int depth);
    void addFlowerToMesh(float thickness, glm::mat4 mat);
    void addLeafToMesh(float thickness, glm::mat4 mat);
    float getExpForDepth(int d);

    // --- 育成パラメータ (b:現在値, t:目標値) ---
    float bLen = 0, bThick = 0, bMutation = 0;
    float tLen = 10, tThick = 2, tMutation = 0;
    float depthExp = 0;
    int depthLevel = 0;

    // --- 状態管理 ---
    ofVboMesh vboMesh; 
    int seed;
    int dayCount = 1;
    float maxMutationReached = 0;
    float lastMutation = 0;
    bool bNeedsUpdate = true;

    // --- JSON定数 ---
    TreeSettings s;
    /*int maxDepthConfig, currentDepth = 0;
    float depthExpBase, depthExpPower;
    float lengthVisualScale, thickVisualScale;
    float branchLenRatio, branchThickRatio;
    float baseAngle, mutationAngleMax;
    float trunkHueStart, trunkHueEnd;
    ofColor leafColor, flowerColor;*/
};
</file>

</files>
